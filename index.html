<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Itinerario de Viaje a Asia 2025 (UTC)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/7.2.1/css/flag-icons.min.css" integrity="sha512-bZBu2H0+FGFz/stDN/L0k8J0G8qVsAL0ht1qg5kTwtAheiXwiRKyCq1frwfbSFSJN3jooR5kauE0YjtPzhZtJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* --- Global Styles & Theme --- */
        :root {
            --primary-color: #059669; /* Emerald-600 */
            --primary-light: #a7f3d0; /* Emerald-200 */
            --bg-color: #f8fafc; /* Slate-50 */
            --card-bg: #ffffff;
        }

        body { font-family: 'Inter', sans-serif; background-color: var(--bg-color); }
        .leaflet-container { border-radius: 0.75rem; z-index: 1; }

        /* --- Loading State --- */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }
        #loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* --- Scrollbar Styles --- */
        .styled-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
        .styled-scrollbar::-webkit-scrollbar-track { background: #f1f5f9; }
        .styled-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .styled-scrollbar::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        /* Custom scrollbar hide utility for timeline */
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }

        /* --- Itinerary Timeline Styles --- */
        .timeline-item-container { position: relative; padding-left: 60px; padding-bottom: 35px; cursor: pointer; transition: opacity 0.3s; }
        .timeline-item-container:hover { opacity: 0.85; }
        .timeline-item-container:last-child { padding-bottom: 10px; }
        .timeline-line { position: absolute; left: 25px; top: 15px; width: 2px; height: 100%; background-color: #e2e8f0; }
        .timeline-item-container:last-child .timeline-line {
            display: none; /* Hide the line after the last item */
        }

        .timeline-icon {
            position: absolute;
            left: 0;
            top: 10px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #e2e8f0; /* Softer default color */
            border: 3px solid var(--card-bg); /* Match card background to create space */
            display: flex;
            align-items: center;
            justify-content: center;
            color: #64748b;
            transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            z-index: 5;
        }
        .timeline-item-container.active .timeline-icon {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-light);
            box-shadow: 0 4px 10px rgba(5, 150, 105, 0.3);
        }
        .material-symbols-outlined { font-size: 24px; }

        /* --- City Overview Timeline Styles --- */
        .city-timeline { position: relative; display: flex; justify-content: space-between; padding: 2rem 0; margin: 0 1rem; }
        .city-timeline::before { content: ''; position: absolute; top: 38px; left: 0; right: 0; height: 4px; background-color: #e2e8f0; z-index: 5; }
        .city-timeline-item { display: flex; flex-direction: column; align-items: center; position: relative; flex-grow: 1; z-index: 10; min-width: 110px; /* Ensure enough space on mobile scroll */ }
        .city-timeline-node { width: 44px; height: 44px; background-color: #fff; border-radius: 50%; border: 3px solid #cbd5e1; transition: border-color 0.3s ease, box-shadow 0.3s ease; flex-shrink: 0; overflow: hidden; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);}
        
        /* Styling for the Flag Icons - Adjusted for better aspect ratio display */
        .city-timeline-node .fi {
            font-size: 32px; /* Adjusted size */
            line-height: 1em;
            /* Removed explicit width/height to allow natural aspect ratio inside the circle */
        }
        /* Specific fix for rectangular flags like Taiwan's to fill the circle */
        .city-timeline-node .fi-tw {
            transform: scale(1.4);
        }

        .city-timeline-item.active .city-timeline-node {
            border-color: var(--primary-color);
            box-shadow: 0 4px 10px rgba(5, 150, 105, 0.3);
        }
        .city-timeline-label { margin-top: 0.75rem; font-size: 0.875rem; font-weight: 600; color: #475569; transition: color 0.3s ease; text-align: center; }
        .city-timeline-item.active .city-timeline-label { color: var(--primary-color); font-weight: 700; }
        .stay-info { display: flex; gap: 0.75rem; margin-top: 0.25rem; color: #64748b; }
        .stay-info-item { display: flex; align-items: center; font-size: 0.8rem; }
        .stay-info-item span:first-child { margin-right: 4px; }
        .stay-info-item .material-symbols-outlined { font-size: 16px; }
        .half-day { margin-right: 0.25rem; }
        .transport-icon { position: absolute; top: -8px; left: 100%; transform: translateX(-50%); background-color: #fff; padding: 6px; border-radius: 50%; z-index: 15; color: #64748b; border: 1px solid #e2e8f0; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        .transport-icon .material-symbols-outlined { font-size: 18px; }
        .city-timeline-item:last-child .transport-icon { display: none; }
        
        /* --- POI Styles (Accordion) --- */
        .poi-category h4 { font-weight: 600; color: #334155; background-color: #f1f5f9; padding: 0.75rem 1rem; border-radius: 0.5rem; margin-bottom: 0.5rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s; }
        .poi-category h4:hover { background-color: #e2e8f0; }
        .poi-category h4 .icon-left { display: flex; align-items: center; }
        .poi-category h4 .material-symbols-outlined { font-size: 20px; margin-right: 8px; }
        .poi-count { font-size: 0.8rem; color: #94a3b8; margin-left: 8px; font-weight: 500; }
        /* Smooth accordion transition */
        .poi-list { max-height: 0; overflow: hidden; transition: max-height 0.5s cubic-bezier(0, 1, 0, 1); padding: 0 0.5rem; }
        .poi-list.open { max-height: 1500px; transition: max-height 0.5s ease-in-out; padding: 0.5rem; }
        .poi-item { margin-bottom: 1rem; padding-left: 1.5rem; border-left: 3px solid #e2e8f0; }
        .poi-name { font-weight: 500; }
        .poi-desc { font-size: 0.875rem; color: #64748b; }
        
        /* --- Map Marker Styles --- */
        .leaflet-div-icon { background: #fff; border: 2px solid #64748b; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
        .leaflet-div-icon .material-symbols-outlined { font-size: 18px; color: #64748b; }

        /* --- Mobile Layout & Navigation --- */
        .shadow-top-lg { box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1), 0 -2px 4px -1px rgba(0, 0, 0, 0.06); }
        .mobile-nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 0.75rem;
            font-weight: 600;
            color: #94a3b8;
            padding: 0.5rem 1rem;
            transition: color 0.2s;
        }
        .mobile-nav-btn.active {
            color: var(--primary-color);
        }
        .mobile-nav-btn .material-symbols-outlined {
            font-size: 28px;
        }

        /* Handle visibility toggling on mobile (Tabbed interface) */
        @media (max-width: 1023px) {
            .mobile-content-area {
                display: none; /* Hide by default */
            }
            .mobile-content-area.active {
                display: block; /* Show when active */
            }
             /* Specific adjustments for containers that need to be flex when active */
             #itinerary-list-container.active, #details-container.active {
                display: flex;
            }
            
            /* Ensure content areas on mobile allow for scrolling and don't have fixed heights */
            #map-container, #itinerary-list-container, #details-container {
                height: auto;
                /* Ensure a minimum height for usability when content is sparse */
                min-height: 60vh; 
            }

            #map {
                 /* Ensure map takes up adequate height when its tab is active */
                 height: 65vh !important; 
            }
        }

    </style>
</head>
<body class="text-slate-800 antialiased">

    <div id="loading-overlay">
        <div class="text-center">
            <svg class="animate-spin h-10 w-10 text-emerald-600 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="mt-4 text-slate-600">Cargando itinerario...</p>
        </div>
    </div>

    <div class="container mx-auto p-4 md:p-6 lg:p-8 pb-24 lg:pb-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-5xl font-extrabold text-slate-900 flex items-center justify-center gap-4">
                <span class="material-symbols-outlined text-emerald-600" style="font-size: 40px;">travel_explore</span>
                Itinerario de Viaje a Asia
            </h1>
            <p class="text-lg md:text-xl text-slate-600 mt-3">Septiembre 27 - Octubre 20, 2025 (Horarios en UTC)</p>
        </header>

        <div id="city-timeline-container" class="bg-white p-4 rounded-xl shadow-xl mb-8 overflow-x-auto whitespace-nowrap scrollbar-hide"></div>

        <main id="main-content" class="grid grid-cols-1 lg:grid-cols-3 gap-8" style="display: none;">
            
            <div id="itinerary-list-container" class="lg:col-span-1 bg-white p-6 rounded-xl shadow-xl flex flex-col lg:h-[85vh] mobile-content-area active" data-mobile-tab="itinerary">
                <div class="flex justify-between items-center border-b pb-4 mb-4">
                    <h2 class="text-2xl font-bold text-slate-900">Plan de Viaje</h2>
                    <div class="flex gap-3">
                        <button id="prevBtn" class="p-2 rounded-lg bg-slate-100 hover:bg-slate-200 text-slate-600 disabled:opacity-50 disabled:cursor-not-allowed transition shadow-sm"><span class="material-symbols-outlined">arrow_back</span></button>
                        <button id="nextBtn" class="p-2 rounded-lg bg-slate-100 hover:bg-slate-200 text-slate-600 disabled:opacity-50 disabled:cursor-not-allowed transition shadow-sm"><span class="material-symbols-outlined">arrow_forward</span></button>
                    </div>
                </div>
                <div id="itinerary-list" class="overflow-y-auto flex-grow pr-3 styled-scrollbar"></div>
            </div>

            <div class="lg:col-span-2 flex flex-col gap-8 lg:h-[85vh]">
                
                <div id="map-container" class="w-full mobile-content-area lg:flex-1" data-mobile-tab="map">
                    <div id="map" class="w-full lg:h-full shadow-xl rounded-xl"></div>
                </div>
                
                <div id="details-container" class="bg-white p-6 rounded-xl shadow-xl flex flex-col mobile-content-area lg:h-[40vh]" data-mobile-tab="details">
                    <h2 id="details-title" class="text-2xl font-bold mb-4 text-slate-900 border-b pb-4">Detalles</h2>
                    <div id="details-content" class="text-slate-700 space-y-4 flex-grow overflow-y-auto pr-3 styled-scrollbar">
                        <p class="text-slate-500 italic mt-4">Selecciona un evento del itinerario para ver los detalles.</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div id="mobile-nav" class="lg:hidden fixed bottom-0 left-0 right-0 bg-white shadow-top-lg border-t border-slate-200 z-50" style="display: none;">
        <div class="flex justify-around py-1">
            <button class="mobile-nav-btn active" data-target="itinerary">
                <span class="material-symbols-outlined">list_alt</span>
                <span>Itinerario</span>
            </button>
            <button class="mobile-nav-btn" data-target="map">
                <span class="material-symbols-outlined">map</span>
                <span>Mapa</span>
            </button>
            <button class="mobile-nav-btn" data-target="details">
                <span class="material-symbols-outlined">info</span>
                <span>Detalles</span>
            </button>
        </div>
    </div>

    <script>
        // --- DATA VARIABLES (To be populated by fetch) ---
        let itineraryData = [];
        let pointsOfInterest = {};
        let sortedData = [];
        let cityStays = {}; // Will be dynamically calculated

        // --- Configuration Constants ---
        // Updated URLs
        const ITINERARY_URL = 'itinerary.json';
        const POI_URL = 'poi.json';

        const poiIcons = {
            'Atracción': 'attractions', 'Templo': 'temple_buddhist', 'Parque': 'park', 'Mirador': 'visibility',
            'Compras': 'shopping_bag', 'Mercado': 'storefront', 'Restaurante': 'restaurant', 'Tienda': 'shopping_cart', 'Tip': 'lightbulb',
        };

        const icons = {
            flight: `<span class="material-symbols-outlined">flight_takeoff</span>`,
            flight_arrival: `<span class="material-symbols-outlined">flight_land</span>`,
            lodging: `<span class="material-symbols-outlined">hotel</span>`,
            sleep: `<span class="material-symbols-outlined">dark_mode</span>`,
            transport: `<span class="material-symbols-outlined">train</span>`,
            activity: `<span class="material-symbols-outlined">local_activity</span>`,
            day_trip: `<span class="material-symbols-outlined">explore</span>`,
            business: `<span class="material-symbols-outlined">work</span>`,
        };
        
        // Flags configuration using flag-icon-css library classes (fi fi-xx)
        const countryFlags = {
            "Tokio": `<span class="fi fi-jp"></span>`,
            "Hakone": `<span class="fi fi-jp"></span>`,
            "Kioto": `<span class="fi fi-jp"></span>`,
            "Osaka": `<span class="fi fi-jp"></span>`,
            "Busán": `<span class="fi fi-kr"></span>`,
            "Seúl": `<span class="fi fi-kr"></span>`,
            "Taipéi": `<span class="fi fi-tw"></span>`,
        };


        // --- Initialization & Setup ---
        
        // Initialize the map with a default view immediately.
        const map = L.map('map').setView([35.6895, 139.6917], 5); 
        
        // Using CartoDB Voyager tileset for a clean look
        L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap contributors &copy; CARTO', maxZoom: 19 }).addTo(map);

        const itineraryList = document.getElementById('itinerary-list');
        const detailsContent = document.getElementById('details-content');
        const detailsTitle = document.getElementById('details-title');
        const cityTimelineContainer = document.getElementById('city-timeline-container');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const loadingOverlay = document.getElementById('loading-overlay');
        const mainContent = document.getElementById('main-content');
        const mobileNav = document.getElementById('mobile-nav');
        // Reference needed for visibility checks
        const mapContainer = document.getElementById('map-container');

        
        let currentDayIndex = 0;
        let mainMarker = null;
        let poiLayerGroup = L.layerGroup().addTo(map);

        // --- COORDINATE PARSING LOGIC (FIXED) ---

        // Helper to process a single coordinate string (e.g., "45.5017° N" or just a number string)
        function parseCoordinateString(coordStr) {
            if (typeof coordStr === 'number') {
                return coordStr;
            }
            if (typeof coordStr !== 'string' || coordStr.trim() === '') {
                return null;
            }

            // 1. Try simple parseFloat first (handles standard signed decimal strings)
            const simpleFloat = parseFloat(coordStr);
            // Check if the entire string (ignoring whitespace) was parsed as a number
            if (!isNaN(simpleFloat) && /^[\s-]?\d+(\.\d+)?\s*$/.test(coordStr)) {
                return simpleFloat;
            }

            // 2. Handle formats like "45.5017° N"
            // Regex to capture the number part (allowing optional degrees symbol) and the direction (N, S, E, W)
            const regex = /([0-9.]+)\s*°?\s*([NSEW])/i;
            const match = coordStr.trim().match(regex);

            if (match) {
                let value = parseFloat(match[1]);
                const direction = match[2].toUpperCase();

                if (isNaN(value)) {
                    return null;
                }

                // Apply sign based on direction (South and West are negative)
                if (direction === 'S' || direction === 'W') {
                    value = -value;
                }
                return value;
            }
            
            // 3. Fallback for formats without direction but with symbols (e.g. "45.5017°")
             const finalFloat = parseFloat(coordStr);
             if (!isNaN(finalFloat)) {
                 return finalFloat;
             }

            return null;
        }

        // Helper function to parse coordinates from various formats to signed decimal degrees.
        function parseCoords(coords) {
            if (!coords || !Array.isArray(coords) || coords.length !== 2) {
                return null;
            }

            const lat = parseCoordinateString(coords[0]);
            const lng = parseCoordinateString(coords[1]);

            // Ensure both coordinates were successfully parsed and are valid numbers
            if (lat !== null && lng !== null && !isNaN(lat) && !isNaN(lng)) {
                // Validate geographical ranges
                if (lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180) {
                    return [lat, lng];
                }
            }

            // If parsing failed or validation failed, return null
            return null;
        }


        // --- DATA FETCHING AND PROCESSING ---
        async function initializeTripData() {
            try {
                const [itineraryResponse, poiResponse] = await Promise.all([
                    fetch(ITINERARY_URL),
                    fetch(POI_URL)
                ]);

                if (!itineraryResponse.ok) throw new Error('Failed to load itinerary data');
                if (!poiResponse.ok) throw new Error('Failed to load POI data');

                const itineraryDataRaw = await itineraryResponse.json();
                const poiDataRaw = await poiResponse.json();

                // Process data (Parse Dates and Coordinates)
                
                // 1. Process itinerary data
                itineraryData = itineraryDataRaw.map(item => ({
                    ...item, 
                    datetime: new Date(item.datetime),
                    coords: parseCoords(item.coords)
                }));
                
                // 2. Process POI data
                pointsOfInterest = {};
                for (const city in poiDataRaw) {
                    pointsOfInterest[city] = poiDataRaw[city].map(poi => ({
                        ...poi,
                        coords: parseCoords(poi.coords)
                    }));
                }

                // Sort data chronologically
                sortedData = itineraryData.sort((a, b) => a.datetime - b.datetime);

                // Dynamically calculate city stays using the robust logic
                cityStays = calculateCityStaysRobust(sortedData);

                // Render the UI only if cityStays was calculated successfully
                if (Object.keys(cityStays).length > 0) {
                    renderUI();
                } else if (sortedData.length > 0) {
                    // If data exists but no stays were calculated, something is unusual about the data structure.
                    throw new Error("Itinerary data loaded, but no city stays could be determined. Check event types and locations.");
                }
                

            } catch (error) {
                console.error("Error initializing trip data:", error);
                // Display error on the loading screen
                 loadingOverlay.innerHTML = `<div class="text-red-500 p-8 bg-white rounded-lg shadow-xl">Error loading or processing data. <br> <small>${error.message}</small></div>`;
            }
        }

        // --- DYNAMIC CITY STAY CALCULATION LOGIC (REFACTORED) ---

        // Robustly calculates city stays based on event types, locations, and datetimes.
        function calculateCityStaysRobust(itinerary) {
            const segments = {};
            if (itinerary.length === 0) return {};

            const sleepEvents = itinerary.filter(e => e.type === 'sleep');
            if (sleepEvents.length === 0) {
                // No sleep events, cannot determine stays.
                return {};
            }

            let currentSegment = {
                city: null,
                start: itinerary[0].datetime,
                end: null,
                transport: null
            };

            let lastSleepCity = null;

            itinerary.forEach((event, i) => {
                if (event.type === 'sleep') {
                    if (lastSleepCity === null) { // First sleep of the trip
                        currentSegment.city = event.location;
                        lastSleepCity = event.location;

                        // Find the actual start of the stay, which is the arrival.
                        for (let j = i; j >= 0; j--) {
                            const pastEvent = itinerary[j];
                            if (pastEvent.location === currentSegment.city && (pastEvent.type === 'flight_arrival' || pastEvent.type === 'transport' || pastEvent.type === 'activity')) {
                                // This is a candidate for the start time. We want the earliest one associated with this city segment.
                                currentSegment.start = pastEvent.datetime;
                            }
                            // Heuristic to stop searching back further than necessary
                            if(pastEvent.type === 'flight' && pastEvent.location !== currentSegment.city) {
                                break;
                            }
                        }

                    } else if (event.location !== lastSleepCity) {
                        // End of a segment, start of a new one.
                        let departureEvent = null;
                        // Look back for the transport event that led to this change of city.
                        for (let j = i; j >= 0; j--) {
                             const prevEvent = itinerary[j];
                             // A flight or transport to a *new* city marks the departure.
                             if ((prevEvent.type === 'flight' || prevEvent.type === 'transport') && prevEvent.location !== lastSleepCity) {
                                 // Check if this transport event is what brought us to the *current* sleep city
                                 // This is tricky. A simpler way is to find the last transport out of the *old* city.
                                 // Let's stick to a simpler heuristic: the transport happened sometime before this new sleep.
                                 departureEvent = prevEvent;
                                 break;
                             }
                        }

                        currentSegment.end = departureEvent ? departureEvent.datetime : event.datetime;
                        currentSegment.transport = departureEvent ? (departureEvent.type === 'flight' ? 'flight_takeoff' : 'train') : 'commute';

                        let segmentName = currentSegment.city;
                        let count = 1;
                        while (segments[segmentName]) {
                            segmentName = `${currentSegment.city} (${count++})`;
                        }
                        segments[segmentName] = {
                            start: currentSegment.start,
                            end: currentSegment.end,
                            transport: currentSegment.transport,
                            baseCity: currentSegment.city,
                        };

                        // Start the new segment.
                        currentSegment = {
                            city: event.location,
                            start: departureEvent ? departureEvent.datetime : event.datetime,
                            end: null,
                            transport: null
                        };
                        lastSleepCity = event.location;
                    }
                }
            });

            // Add the final segment.
            if (currentSegment.city) {
                currentSegment.end = itinerary[itinerary.length - 1].datetime;
                const lastEvent = itinerary[itinerary.length - 1];
                if (lastEvent.type === 'flight') {
                    currentSegment.transport = 'flight_takeoff';
                } else if (lastEvent.type === 'transport') {
                    currentSegment.transport = 'train';
                }

                let segmentName = currentSegment.city;
                let count = 1;
                while (segments[segmentName]) {
                    segmentName = `${currentSegment.city} (${count++})`;
                }
                segments[segmentName] = {
                    start: currentSegment.start,
                    end: currentSegment.end,
                    transport: currentSegment.transport,
                    baseCity: currentSegment.city,
                };
            }

            // Handle cases where we visit the same city multiple times (e.g., Tokyo).
            const orderedSegments = Object.keys(segments).sort((a, b) => segments[a].start - segments[b].start);

            const finalSegments = {};
            const cityVisits = {};

            orderedSegments.forEach(name => {
                const segment = segments[name];
                const baseCity = segment.baseCity;
                cityVisits[baseCity] = (cityVisits[baseCity] || 0) + 1;
            });

            const multiVisitCities = Object.keys(cityVisits).filter(city => cityVisits[city] > 1);
            const cityCounters = {};

            orderedSegments.forEach(name => {
                const segment = segments[name];
                const baseCity = segment.baseCity;
                let newName = baseCity;

                if (multiVisitCities.includes(baseCity)) {
                    cityCounters[baseCity] = (cityCounters[baseCity] || 0) + 1;
                    newName = `${baseCity} (${cityCounters[baseCity]})`;
                }
                finalSegments[newName] = segment;
                finalSegments[newName].flag = countryFlags[baseCity] || '';
            });


            return calculateDurations(finalSegments);
        }


        // Applies the specific rules for counting days and nights (UTC based)
        function calculateDurations(segments) {
             // ... (The duration calculation logic remains the same) ...
            const THRESHOLD_1PM = 13 * 60; // 13:00 in minutes UTC
            const THRESHOLD_6PM = 18 * 60; // 18:00 in minutes UTC
            const MS_IN_A_DAY = 24 * 60 * 60 * 1000;

            const results = {};

            const orderedSegmentNames = Object.keys(segments).sort((a, b) => segments[a].start - segments[b].start);

            for (const name of orderedSegmentNames) {
                const segment = segments[name];
                let days = 0;

                const start = segment.start;
                const end = segment.end;

                const startTimeInMinutes = start.getUTCHours() * 60 + start.getUTCMinutes();
                const endTimeInMinutes = end.getUTCHours() * 60 + end.getUTCMinutes();

                const startDateUTC = new Date(Date.UTC(start.getUTCFullYear(), start.getUTCMonth(), start.getUTCDate()));
                const endDateUTC = new Date(Date.UTC(end.getUTCFullYear(), end.getUTCMonth(), end.getUTCDate()));

                let nights = Math.round((endDateUTC - startDateUTC) / MS_IN_A_DAY);

                if (nights === 0) {
                    if (startTimeInMinutes < THRESHOLD_6PM) {
                         if (startTimeInMinutes < THRESHOLD_1PM && endTimeInMinutes >= THRESHOLD_1PM) {
                            days = 1;
                         } else {
                             if ((end.getTime() - start.getTime()) >= (3 * 60 * 60 * 1000)) {
                                days = 0.5;
                             }
                         }
                    }
                } else {
                    days = nights - 1;

                    if (startTimeInMinutes < THRESHOLD_1PM) {
                        days += 1;
                    } else if (startTimeInMinutes < THRESHOLD_6PM) {
                        days += 0.5;
                    }

                    if (endTimeInMinutes >= THRESHOLD_1PM) {
                        days += 0.5; 
                    }
                }


                const formattedDays = String(days).replace('.5', '½');

                results[name] = {
                    days: formattedDays,
                    nights: String(nights),
                    transportToNext: segment.transport,
                    startTime: segment.start,
                    flag: segment.flag
                };
            }
            return results;
        }


        // --- UI RENDERING ---

        // Initialization sequence
        function renderUI() {
            // 1. Render static components first
            renderCityTimeline();
            renderItinerary();
            
            // 2. Show content and hide loader
            mainContent.style.display = 'grid';
            if (window.innerWidth < 1024) {
                 mobileNav.style.display = 'block';
            }
            // Only hide if no error message was displayed during initialization
            if (loadingOverlay.innerHTML.includes('Cargando itinerario')) {
                loadingOverlay.classList.add('hidden');
            }

            // 3. Invalidate size so the map knows its dimensions now that it is visible.
            // Note: On mobile, the map might still be hidden if the map tab is not active.
            map.invalidateSize();
            
            // 4. Now update the view (which includes map movements/flyTo).
            updateView();
        }


        // --- RENDER FUNCTIONS ---

        function renderItinerary() {
            itineraryList.innerHTML = '';
            // Group items by date
            const groupedByDate = sortedData.reduce((acc, item, index) => {
                // Use timeZone: 'UTC' to ensure the date grouping is based on the UTC date
                const dateKey = item.datetime.toLocaleDateString('es-ES', { weekday: 'long', month: 'long', day: 'numeric', timeZone: 'UTC' });
                if (!acc[dateKey]) { acc[dateKey] = []; }
                acc[dateKey].push({ ...item, originalIndex: index });
                return acc;
            }, {});

            for (const date in groupedByDate) {
                const dayGroup = document.createElement('div');
                const dayHeader = document.createElement('h3');
                // Added sticky header for better navigation within the list
                dayHeader.className = 'text-lg font-bold text-slate-900 mb-4 pt-5 sticky top-0 bg-white py-2 z-10 shadow-sm';
                dayHeader.textContent = date.charAt(0).toUpperCase() + date.slice(1);
                dayGroup.appendChild(dayHeader);

                groupedByDate[date].forEach(item => {
                    // Use timeZone: 'UTC' to ensure the time displayed is UTC
                    const timeString = item.datetime.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', hour12: true, timeZone: 'UTC' });
                    const container = document.createElement('div');
                    container.className = 'timeline-item-container';
                    container.dataset.index = item.originalIndex;
                    
                    // Refined HTML structure for the timeline item content
                    container.innerHTML = `
                        <div class="timeline-line"></div>
                        <div class="timeline-icon">${icons[item.type] || icons.activity}</div>
                        <div class="timeline-content">
                            <p class="text-sm font-semibold text-slate-500">${timeString}</p>
                            <p class="font-semibold text-lg text-slate-800 mt-1">${item.title}</p>
                            <p class="text-sm text-slate-600 flex items-center gap-2 mt-1">
                                <span class="material-symbols-outlined" style="font-size: 16px;">location_on</span>
                                ${item.location}
                            </p>
                            ${item.duration ? `
                                <div class="flex items-center text-sm text-slate-600 mt-1">
                                    <span class="material-symbols-outlined" style="font-size: 16px; margin-right: 8px;">schedule</span>
                                    <span>${item.duration}</span>
                                </div>` : ''}
                        </div>`;
                    
                    container.addEventListener('click', () => { 
                        currentDayIndex = item.originalIndex; 
                        updateView(); 
                        // On mobile, automatically switch to the details tab when an item is clicked
                        if (window.innerWidth < 1024) {
                            // Don't force switch to details if the user is actively viewing the map
                            const mapTabIsActive = document.querySelector('.mobile-nav-btn[data-target="map"]').classList.contains('active');
                            if (!mapTabIsActive) {
                                switchToMobileTab('details');
                            }
                        }
                    });
                    dayGroup.appendChild(container);
                });
                itineraryList.appendChild(dayGroup);
            }
        }
        

        function renderCityTimeline() {
            // The order is determined by the chronological calculation in calculateCityStaysRobust/calculateDurations.
            const cityOrder = Object.keys(cityStays);

            const timelineDiv = document.createElement('div');
            timelineDiv.className = 'city-timeline';
            
            cityOrder.forEach(city => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'city-timeline-item';
                itemDiv.dataset.city = city;
                
                // Get the dynamically calculated stay info
                const stayInfo = cityStays[city];
                
                // HTML for stay info (days/nights)
                let stayHtml = stayInfo ? `
                    <div class="stay-info">
                        <div class="stay-info-item" title="${stayInfo.days} Días">
                            <span class="material-symbols-outlined">wb_sunny</span>
                            <span class="${String(stayInfo.days).includes('½') ? 'half-day' : ''}">${stayInfo.days}</span>
                        </div>
                        <div class="stay-info-item" title="${stayInfo.nights} Noches">
                            <span class="material-symbols-outlined">dark_mode</span>
                            <span>${stayInfo.nights}</span>
                        </div>
                    </div>` : '';
                
                // HTML for transport icon between cities
                let transportHtml = (stayInfo && stayInfo.transportToNext) ? `
                    <div class="transport-icon">
                        <span class="material-symbols-outlined">${stayInfo.transportToNext}</span>
                    </div>` : '';
                
                // The countryFlags[city] inserts the <span> element required by the flag-icon-css library
                // The keys in countryFlags are configured to match the visualization names generated.
                itemDiv.innerHTML = `
                    <div class="city-timeline-node">${stayInfo.flag || ''}</div>
                    <div class="city-timeline-label">${city}</div>
                    ${stayHtml}
                    ${transportHtml}`;
                timelineDiv.appendChild(itemDiv);
            });
            cityTimelineContainer.innerHTML = '';
            if (Object.keys(cityStays).length > 0) {
                cityTimelineContainer.appendChild(timelineDiv);
            }
        }

        // --- UPDATE VIEW LOGIC ---

        function updateView() {
            if (sortedData.length === 0) return;

            const currentItem = sortedData[currentDayIndex];
            
            // 1. Update Itinerary List Active State
            document.querySelectorAll('.timeline-item-container').forEach(el => el.classList.remove('active'));
            const activeEl = document.querySelector(`.timeline-item-container[data-index="${currentDayIndex}"]`);
            if (activeEl) {
                activeEl.classList.add('active');
                // Smooth scroll the active item into view
                activeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            
            // 2. Clear Map Layers
            poiLayerGroup.clearLayers();
            if (mainMarker) map.removeLayer(mainMarker);

            // 3. Determine Details Content (POI or Event Details)
            const cityEventTypes = ['activity', 'sleep', 'day_trip', 'business', 'lodging'];
            let displayLocation = currentItem.location;
            
            // Map specific sub-locations/day trips to major areas if needed for POI lookup.
            const cityMap = {
                "Susono": "Hakone",
                "Narita": "Tokyo",
                "Gyeongju": "Busan"
            };
            
            // Normalize the location name using the map. If not in map, use the original name.
            let poiLookupLocation = cityMap[displayLocation] || displayLocation;
            

            if (cityEventTypes.includes(currentItem.type) && pointsOfInterest[poiLookupLocation]) {
                // Show POIs for the city
                detailsTitle.textContent = `Atracciones en ${currentItem.location}`;
                const cityPOIs = pointsOfInterest[poiLookupLocation];
                
                // Group POIs by category
                const groupedPOIs = cityPOIs.reduce((acc, poi) => {
                    if (!acc[poi.category]) acc[poi.category] = [];
                    acc[poi.category].push(poi);
                    return acc;
                }, {});

                let poiHtml = '<div class="space-y-5 mt-2">';
                
                // Add a highlight box if accommodation needs booking
                if (currentItem.details?.Alojamiento === "NEED TO BOOK") {
                    poiHtml += `<div class="p-4 mb-4 text-sm text-red-800 rounded-lg bg-red-50" role="alert">
                                    <span class="font-medium">¡Atención!</span> Necesitas reservar alojamiento para esta noche.
                                </div>`;
                }

                for (const category in groupedPOIs) {
                    // Get the count for the category
                    const count = groupedPOIs[category].length;

                    // Render collapsible category headers
                    poiHtml += `
                        <div class="poi-category">
                            <h4 onclick="this.nextElementSibling.classList.toggle('open')">
                                <span class="icon-left">
                                    <span class="material-symbols-outlined">${poiIcons[category] || 'place'}</span>
                                    ${category}
                                    <span class="poi-count">(${count})</span>
                                </span>
                                <span class="material-symbols-outlined">expand_more</span>
                            </h4>
                            <div class="poi-list">`;
                    
                    groupedPOIs[category].forEach(poi => {
                        // Render POI details
                        poiHtml += `
                            <div class="poi-item">
                                <p class="poi-name">${poi.name}</p>
                                <p class="poi-desc">${poi.description}</p>
                            </div>`;
                        
                        // Add POI markers to the map (robust check ensured by parseCoords)
                        if (poi.coords) {
                            const iconHtml = `<span class="material-symbols-outlined">${poiIcons[poi.category] || 'place'}</span>`;
                            const divIcon = L.divIcon({ className: 'leaflet-div-icon', html: iconHtml, iconSize: [30, 30], iconAnchor: [15, 15] });
                            L.marker(poi.coords, { icon: divIcon }).addTo(poiLayerGroup).bindPopup(`<b>${poi.name}</b><br>${poi.category}`);
                        }
                    });
                    poiHtml += `</div></div>`;
                }
                 detailsContent.innerHTML = poiHtml + '</div>' || '<p class="text-slate-500 italic mt-4">No hay puntos de interés para esta ciudad.</p>';
            } else {
                // Show specific event details (e.g., Flight Info)
                detailsTitle.textContent = 'Detalles del Evento';
                let detailsHtml = `<div class="mt-4 p-5 bg-slate-50 rounded-lg shadow-sm"><h3 class="text-xl font-bold text-slate-800 mb-4">${currentItem.title}</h3><div class="space-y-3">`;
                if (currentItem.details) {
                    for (const [key, value] of Object.entries(currentItem.details)) {
                        detailsHtml += `<p><strong class="text-slate-600">${key}:</strong> ${value}</p>`;
                    }
                } else {
                     // If no specific details, check if POIs were missing for an activity type
                     if (cityEventTypes.includes(currentItem.type) && !pointsOfInterest[poiLookupLocation]) {
                        detailsHtml += `<p class="text-slate-500 italic">No hay puntos de interés registrados para ${currentItem.location}.</p>`;
                    } else {
                        detailsHtml += `<p class="text-slate-500 italic">No hay detalles adicionales.</p>`;
                    }
                }
                detailsContent.innerHTML = detailsHtml + '</div></div>';
            }

            // 4. Update Map View and Main Marker
            
            // FIX: Check if the map container is currently visible (relevant for mobile tabs)
            // Define the LG breakpoint (1024px) used in the CSS.
            const LG_BREAKPOINT = 1024;
            const mapIsVisible = window.innerWidth >= LG_BREAKPOINT || (window.innerWidth < LG_BREAKPOINT && mapContainer.classList.contains('active'));

            // Improved logic to handle coordinates and fallbacks gracefully.
            if (currentItem.coords && currentItem.location.toLowerCase() !== "en vuelo") {
                // Case A: Event has valid coordinates.
                
                // Create a distinct marker for the main event
                const mainIconHtml = `<div style="background-color: var(--primary-color); color: white; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; border: 3px solid white; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">${icons[currentItem.type] || icons.activity}</div>`;
                const mainIcon = L.divIcon({ className: '', html: mainIconHtml, iconSize: [36, 36], iconAnchor: [18, 18] });

                mainMarker = L.marker(currentItem.coords, { icon: mainIcon }).addTo(map).bindPopup(`<b>${currentItem.title}</b><br>${currentItem.location}`);
                
                // FIX: Use animation (flyTo) ONLY if the map is visible.
                // If hidden, use setView immediately to avoid animation errors (NaN, NaN) with 0 dimensions.
                if (mapIsVisible) {
                    map.flyTo(currentItem.coords, 13, { animate: true, duration: 1.5 });
                    mainMarker.openPopup();
                } else {
                    // Update the map center so when the user switches to the map tab, it's correct.
                    map.setView(currentItem.coords, 13, { animate: false });
                }
               
            } else if (currentItem.location.toLowerCase() !== "en vuelo") {
                // Case B: Event does not have coordinates (but is not "en vuelo"). 
                // Try to center based on the POIs that were just added to the poiLayerGroup.

                if (poiLayerGroup.getLayers().length > 0) {
                    const bounds = poiLayerGroup.getBounds();
                    if (bounds.isValid()) {
                         // Use animation (flyToBounds) ONLY if the map is visible.
                        if (mapIsVisible) {
                            map.flyToBounds(bounds, { animate: true, duration: 1.5, padding: [50, 50], maxZoom: 14 });
                        } else {
                            // Use fitBounds without animation if hidden.
                            map.fitBounds(bounds, { animate: false, padding: [50, 50], maxZoom: 14 });
                        }
                    }
                }
                 // Case C: No event coords and no POIs. Do nothing, map stays centered on the previous location.
            }

            // 5. Update City Timeline Active State
            updateCityTimeline();
            
            // 6. Update Navigation Buttons State
            prevBtn.disabled = currentDayIndex === 0;
            nextBtn.disabled = currentDayIndex === sortedData.length - 1;
        }

        // Determines the active city based on the current event's timestamp and the calculated segments.
        function updateCityTimeline() {
            document.querySelectorAll('.city-timeline-item').forEach(el => el.classList.remove('active'));
            
            if (sortedData.length === 0) return;

            const currentTime = sortedData[currentDayIndex].datetime;
            let activeCity = null;

            // Iterate through the calculated city stays (which are chronologically ordered).
            for (const cityName in cityStays) {
                const stay = cityStays[cityName];
                // Check if the current event time is greater than or equal to the segment start time.
                // Since the iteration is chronological, the last segment that satisfies this condition is the active one.
                if (currentTime >= stay.startTime) {
                    activeCity = cityName;
                }
            }
            
            if(activeCity) {
                const activeCityEl = document.querySelector(`.city-timeline-item[data-city="${activeCity}"]`);
                if (activeCityEl) {
                    activeCityEl.classList.add('active');
                    // Ensure the active city is visible in the horizontal scroll
                    activeCityEl.scrollIntoView({ behavior: 'smooth', inline: 'center' });
                }
            }
        }

        // --- Event Handlers ---
        prevBtn.addEventListener('click', () => { if (currentDayIndex > 0) { currentDayIndex--; updateView(); } });
        nextBtn.addEventListener('click', () => { if (currentDayIndex < sortedData.length - 1) { currentDayIndex++; updateView(); } });

        // --- Mobile Navigation Logic ---
        const mobileNavBtns = document.querySelectorAll('.mobile-nav-btn');
        
        // Define references to the containers using the data-mobile-tab attribute
        const itineraryContainer = document.querySelector('[data-mobile-tab="itinerary"]');
        // const mapContainer = document.querySelector('[data-mobile-tab="map"]'); // Already defined globally
        const detailsContainer = document.querySelector('[data-mobile-tab="details"]');

        const mobileContainers = {
            'itinerary': itineraryContainer,
            'map': mapContainer,
            'details': detailsContainer
        };

        function switchToMobileTab(target) {
            // Update button active state
            mobileNavBtns.forEach(b => b.classList.remove('active'));
            const activeBtn = document.querySelector(`.mobile-nav-btn[data-target="${target}"]`);
            if (activeBtn) activeBtn.classList.add('active');

            // Update content area visibility
            for (const key in mobileContainers) {
                if (key === target) {
                    mobileContainers[key].classList.add('active');
                } else {
                    mobileContainers[key].classList.remove('active');
                }
            }

            // Specific action for map tab: invalidate size and potentially update view
            if (target === 'map') {
                // Use a slight delay to ensure the container is visible before invalidating size
                setTimeout(() => {
                    map.invalidateSize();
                    // Re-run updateView when switching to map tab to ensure flyTo/flyToBounds animation runs now that the map is visible
                    updateView(); 
                }, 10);
            }
        }

        mobileNavBtns.forEach(btn => {
            btn.addEventListener('click', () => switchToMobileTab(btn.dataset.target));
        });


        // --- Start the Application ---
        initializeTripData();

    </script>
</body>
</html>
