<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Itinerario de Viaje a Asia 2025 (UTC)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/7.2.1/css/flag-icons.min.css" integrity="sha512-bZBu2H0+FGFz/stDN/L0k8J0G8qVsAL0ht1qg5kTwtAheiXwiRKyCq1frwfbSFSJN3jooR5kauE0YjtPzhZtJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* --- Global Styles & Theme --- */
        :root {
            --primary-color: #059669; /* Emerald-600 */
            --primary-light: #a7f3d0; /* Emerald-200 */
            --bg-color: #f8fafc; /* Slate-50 */
            --card-bg: #ffffff;
        }

        body { font-family: 'Inter', sans-serif; background-color: var(--bg-color); }
        .leaflet-container { border-radius: 0.75rem; z-index: 1; }

        /* --- Loading State --- */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }
        #loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* --- Scrollbar Styles --- */
        .styled-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
        .styled-scrollbar::-webkit-scrollbar-track { background: #f1f5f9; }
        .styled-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .styled-scrollbar::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        /* Custom scrollbar hide utility for timeline */
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }

        /* --- Itinerary Timeline Styles --- */
        .timeline-item-container { position: relative; padding-left: 60px; padding-bottom: 35px; cursor: pointer; transition: opacity 0.3s; }
        .timeline-item-container:hover { opacity: 0.85; }
        .timeline-item-container:last-child { padding-bottom: 10px; }
        .timeline-line { position: absolute; left: 25px; top: 15px; width: 2px; height: 100%; background-color: #e2e8f0; }
        .timeline-item-container:last-child .timeline-line {
            display: none; /* Hide the line after the last item */
        }

        .timeline-icon {
            position: absolute;
            left: 0;
            top: 10px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #e2e8f0; /* Softer default color */
            border: 3px solid var(--card-bg); /* Match card background to create space */
            display: flex;
            align-items: center;
            justify-content: center;
            color: #64748b;
            transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            z-index: 5;
        }
        .timeline-item-container.active .timeline-icon {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-light);
            box-shadow: 0 4px 10px rgba(5, 150, 105, 0.3);
        }
        .material-symbols-outlined { font-size: 24px; }

        /* --- City Overview Timeline Styles --- */
        .city-timeline { position: relative; display: flex; justify-content: space-between; padding: 2rem 0; margin: 0 1rem; }
        .city-timeline::before { content: ''; position: absolute; top: 38px; left: 0; right: 0; height: 4px; background-color: #e2e8f0; z-index: 5; }
        .city-timeline-item { display: flex; flex-direction: column; align-items: center; position: relative; flex-grow: 1; z-index: 10; min-width: 110px; /* Ensure enough space on mobile scroll */ }
        .city-timeline-node { width: 44px; height: 44px; background-color: #fff; border-radius: 50%; border: 3px solid #cbd5e1; transition: border-color 0.3s ease, box-shadow 0.3s ease; flex-shrink: 0; overflow: hidden; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);}
        
        /* Styling for the Flag Icons - Adjusted for better aspect ratio display */
        .city-timeline-node .fi {
            font-size: 32px; /* Adjusted size */
            line-height: 1em;
            /* Removed explicit width/height to allow natural aspect ratio inside the circle */
        }

        .city-timeline-item.active .city-timeline-node {
            border-color: var(--primary-color);
            box-shadow: 0 4px 10px rgba(5, 150, 105, 0.3);
        }
        .city-timeline-label { margin-top: 0.75rem; font-size: 0.875rem; font-weight: 600; color: #475569; transition: color 0.3s ease; text-align: center; }
        .city-timeline-item.active .city-timeline-label { color: var(--primary-color); font-weight: 700; }
        .stay-info { display: flex; gap: 0.75rem; margin-top: 0.25rem; color: #64748b; }
        .stay-info-item { display: flex; align-items: center; font-size: 0.8rem; }
        .stay-info-item span:first-child { margin-right: 4px; }
        .stay-info-item .material-symbols-outlined { font-size: 16px; }
        .half-day { margin-right: 0.25rem; }
        .transport-icon { position: absolute; top: -8px; left: 100%; transform: translateX(-50%); background-color: #fff; padding: 6px; border-radius: 50%; z-index: 15; color: #64748b; border: 1px solid #e2e8f0; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        .transport-icon .material-symbols-outlined { font-size: 18px; }
        .city-timeline-item:last-child .transport-icon { display: none; }
        
        /* --- POI Styles (Accordion) --- */
        .poi-category h4 { font-weight: 600; color: #334155; background-color: #f1f5f9; padding: 0.75rem 1rem; border-radius: 0.5rem; margin-bottom: 0.5rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s; }
        .poi-category h4:hover { background-color: #e2e8f0; }
        .poi-category h4 .icon-left { display: flex; align-items: center; }
        .poi-category h4 .material-symbols-outlined { font-size: 20px; margin-right: 8px; }
        .poi-count { font-size: 0.8rem; color: #94a3b8; margin-left: 8px; font-weight: 500; }
        /* Smooth accordion transition */
        .poi-list { max-height: 0; overflow: hidden; transition: max-height 0.5s cubic-bezier(0, 1, 0, 1); padding: 0 0.5rem; }
        .poi-list.open { max-height: 1500px; transition: max-height 0.5s ease-in-out; padding: 0.5rem; }
        .poi-item { margin-bottom: 1rem; padding-left: 1.5rem; border-left: 3px solid #e2e8f0; }
        .poi-name { font-weight: 500; }
        .poi-desc { font-size: 0.875rem; color: #64748b; }
        
        /* --- Map Marker Styles --- */
        .leaflet-div-icon { background: #fff; border: 2px solid #64748b; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
        .leaflet-div-icon .material-symbols-outlined { font-size: 18px; color: #64748b; }

        /* --- Mobile Layout & Navigation --- */
        .shadow-top-lg { box-shadow: 0 -4px 6px -1px rgba(0, 0, 0, 0.1), 0 -2px 4px -1px rgba(0, 0, 0, 0.06); }
        .mobile-nav-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 0.75rem;
            font-weight: 600;
            color: #94a3b8;
            padding: 0.5rem 1rem;
            transition: color 0.2s;
        }
        .mobile-nav-btn.active {
            color: var(--primary-color);
        }
        .mobile-nav-btn .material-symbols-outlined {
            font-size: 28px;
        }

        /* Handle visibility toggling on mobile (Tabbed interface) */
        @media (max-width: 1023px) {
            .mobile-content-area {
                display: none; /* Hide by default */
            }
            .mobile-content-area.active {
                display: block; /* Show when active */
            }
             /* Specific adjustments for containers that need to be flex when active */
             #itinerary-list-container.active, #details-container.active {
                display: flex;
            }
            
            /* Ensure content areas on mobile allow for scrolling and don't have fixed heights */
            #map-container, #itinerary-list-container, #details-container {
                height: auto;
                /* Ensure a minimum height for usability when content is sparse */
                min-height: 60vh; 
            }

            #map {
                 /* Ensure map takes up adequate height when its tab is active */
                 height: 65vh !important; 
            }
        }

    </style>
</head>
<body class="text-slate-800 antialiased">

    <div id="loading-overlay">
        <div class="text-center">
            <svg class="animate-spin h-10 w-10 text-emerald-600 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="mt-4 text-slate-600">Cargando itinerario...</p>
        </div>
    </div>

    <div class="container mx-auto p-4 md:p-6 lg:p-8 pb-24 lg:pb-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-5xl font-extrabold text-slate-900 flex items-center justify-center gap-4">
                <span class="material-symbols-outlined text-emerald-600" style="font-size: 40px;">travel_explore</span>
                Itinerario de Viaje a Asia
            </h1>
            <p class="text-lg md:text-xl text-slate-600 mt-3">Septiembre 27 - Octubre 20, 2025 (Horarios en UTC)</p>
        </header>

        <div id="city-timeline-container" class="bg-white p-4 rounded-xl shadow-xl mb-8 overflow-x-auto whitespace-nowrap scrollbar-hide"></div>

        <main id="main-content" class="grid grid-cols-1 lg:grid-cols-3 gap-8" style="display: none;">
            
            <div id="itinerary-list-container" class="lg:col-span-1 bg-white p-6 rounded-xl shadow-xl flex flex-col lg:h-[85vh] mobile-content-area active" data-mobile-tab="itinerary">
                <div class="flex justify-between items-center border-b pb-4 mb-4">
                    <h2 class="text-2xl font-bold text-slate-900">Plan de Viaje</h2>
                    <div class="flex gap-3">
                        <button id="prevBtn" class="p-2 rounded-lg bg-slate-100 hover:bg-slate-200 text-slate-600 disabled:opacity-50 disabled:cursor-not-allowed transition shadow-sm"><span class="material-symbols-outlined">arrow_back</span></button>
                        <button id="nextBtn" class="p-2 rounded-lg bg-slate-100 hover:bg-slate-200 text-slate-600 disabled:opacity-50 disabled:cursor-not-allowed transition shadow-sm"><span class="material-symbols-outlined">arrow_forward</span></button>
                    </div>
                </div>
                <div id="itinerary-list" class="overflow-y-auto flex-grow pr-3 styled-scrollbar"></div>
            </div>

            <div class="lg:col-span-2 flex flex-col gap-8 lg:h-[85vh]">
                
                <div id="map-container" class="w-full mobile-content-area lg:flex-1" data-mobile-tab="map">
                    <div id="map" class="w-full lg:h-full shadow-xl rounded-xl"></div>
                </div>
                
                <div id="details-container" class="bg-white p-6 rounded-xl shadow-xl flex flex-col mobile-content-area lg:h-[40vh]" data-mobile-tab="details">
                    <h2 id="details-title" class="text-2xl font-bold mb-4 text-slate-900 border-b pb-4">Detalles</h2>
                    <div id="details-content" class="text-slate-700 space-y-4 flex-grow overflow-y-auto pr-3 styled-scrollbar">
                        <p class="text-slate-500 italic mt-4">Selecciona un evento del itinerario para ver los detalles.</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div id="mobile-nav" class="lg:hidden fixed bottom-0 left-0 right-0 bg-white shadow-top-lg border-t border-slate-200 z-50" style="display: none;">
        <div class="flex justify-around py-1">
            <button class="mobile-nav-btn active" data-target="itinerary">
                <span class="material-symbols-outlined">list_alt</span>
                <span>Itinerario</span>
            </button>
            <button class="mobile-nav-btn" data-target="map">
                <span class="material-symbols-outlined">map</span>
                <span>Mapa</span>
            </button>
            <button class="mobile-nav-btn" data-target="details">
                <span class="material-symbols-outlined">info</span>
                <span>Detalles</span>
            </button>
        </div>
    </div>

    <script>
        // --- DATA VARIABLES (To be populated by fetch) ---
        let itineraryData = [];
        let pointsOfInterest = {};
        let sortedData = [];
        let cityStays = {}; // Will be dynamically calculated

        // --- Configuration Constants ---
        // Updated URLs
        const ITINERARY_URL = 'itinerary.json';
        const POI_URL = 'poi.json';

        const poiIcons = {
            'Atracción': 'attractions', 'Templo': 'temple_buddhist', 'Parque': 'park', 'Mirador': 'visibility',
            'Compras': 'shopping_bag', 'Mercado': 'storefront', 'Restaurante': 'restaurant', 'Tienda': 'shopping_cart', 'Tip': 'lightbulb',
        };

        const icons = {
            flight: `<span class="material-symbols-outlined">flight_takeoff</span>`,
            flight_arrival: `<span class="material-symbols-outlined">flight_land</span>`,
            lodging: `<span class="material-symbols-outlined">hotel</span>`,
            sleep: `<span class="material-symbols-outlined">dark_mode</span>`,
            transport: `<span class="material-symbols-outlined">train</span>`,
            activity: `<span class="material-symbols-outlined">local_activity</span>`,
            day_trip: `<span class="material-symbols-outlined">explore</span>`,
            business: `<span class="material-symbols-outlined">work</span>`,
        };
        
        // Flags configuration using flag-icon-css library classes (fi fi-xx)
        // Updated to include all potential dynamic names generated by the robust calculation logic.
        const countryFlags = {
            "Tokio (Inicio)": `<span class="fi fi-jp"></span>`,
            "Tokio (Fin)": `<span class="fi fi-jp"></span>`,
            "Tokio": `<span class="fi fi-jp"></span>`,
            "Hakone": `<span class="fi fi-jp"></span>`,
            "Kyoto (+ Nara)": `<span class="fi fi-jp"></span>`,
            "Kyoto": `<span class="fi fi-jp"></span>`,
            "Osaka": `<span class="fi fi-jp"></span>`,
            "Busan (+ Gyeongju)": `<span class="fi fi-kr"></span>`,
            "Busan": `<span class="fi fi-kr"></span>`,
            "Seúl": `<span class="fi fi-kr"></span>`,
            "Taipéi": `<span class="fi fi-tw"></span>`,
        };


        // --- Initialization & Setup ---
        
        // Initialize the map with a default view immediately.
        const map = L.map('map').setView([35.6895, 139.6917], 5); 
        
        // Using CartoDB Voyager tileset for a clean look
        L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap contributors &copy; CARTO', maxZoom: 19 }).addTo(map);

        const itineraryList = document.getElementById('itinerary-list');
        const detailsContent = document.getElementById('details-content');
        const detailsTitle = document.getElementById('details-title');
        const cityTimelineContainer = document.getElementById('city-timeline-container');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const loadingOverlay = document.getElementById('loading-overlay');
        const mainContent = document.getElementById('main-content');
        const mobileNav = document.getElementById('mobile-nav');
        
        let currentDayIndex = 0;
        let mainMarker = null;
        let poiLayerGroup = L.layerGroup().addTo(map);

        // Helper function to safely parse coordinates from strings to numbers
        function parseCoords(coords) {
            if (coords && Array.isArray(coords) && coords.length === 2) {
                // Ensure we handle both string and number inputs gracefully
                const lat = parseFloat(coords[0]);
                const lng = parseFloat(coords[1]);
                if (!isNaN(lat) && !isNaN(lng)) {
                    return [lat, lng];
                }
            }
            return null;
        }

        // --- DATA FETCHING AND PROCESSING ---
        async function initializeTripData() {
            try {
                const [itineraryResponse, poiResponse] = await Promise.all([
                    fetch(ITINERARY_URL),
                    fetch(POI_URL)
                ]);

                if (!itineraryResponse.ok) throw new Error('Failed to load itinerary data');
                if (!poiResponse.ok) throw new Error('Failed to load POI data');

                const itineraryDataRaw = await itineraryResponse.json();
                const poiDataRaw = await poiResponse.json();

                // Process data (Parse Dates and Coordinates)
                
                // 1. Process itinerary data
                itineraryData = itineraryDataRaw.map(item => ({
                    ...item, 
                    datetime: new Date(item.datetime),
                    coords: parseCoords(item.coords)
                }));
                
                // 2. Process POI data
                pointsOfInterest = {};
                for (const city in poiDataRaw) {
                    pointsOfInterest[city] = poiDataRaw[city].map(poi => ({
                        ...poi,
                        coords: parseCoords(poi.coords)
                    }));
                }

                // Sort data chronologically
                sortedData = itineraryData.sort((a, b) => a.datetime - b.datetime);

                // Dynamically calculate city stays using the robust logic
                // We rename the function call to the new implementation.
                cityStays = calculateCityStaysRobust(sortedData);

                // Render the UI only if cityStays was calculated successfully
                if (Object.keys(cityStays).length > 0) {
                    renderUI();
                } else if (sortedData.length > 0) {
                    // If data exists but no stays were calculated, something is unusual about the data structure.
                    throw new Error("Itinerary data loaded, but no city stays could be determined. Check event types and locations.");
                }
                

            } catch (error) {
                console.error("Error initializing trip data:", error);
                // Display error on the loading screen
                 loadingOverlay.innerHTML = `<div class="text-red-500 p-8 bg-white rounded-lg shadow-xl">Error loading or processing data. <br> <small>${error.message}</small></div>`;
            }
        }

        // --- DYNAMIC CITY STAY CALCULATION LOGIC (REFACTORED) ---

        // Helper to calculate arrival time from duration string (Handles formats like "~2h 30m" or "~14h")
        function calculateArrivalTime(startTime, durationString) {
            if (!durationString) return startTime;

            let durationMs = 0;
            // Simplified regex to capture hours and minutes, ignoring the '~'
            const regex = /(\d+)\s*h|(\d+)\s*m/g;
            let match;

            while ((match = regex.exec(durationString)) !== null) {
                if (match[1]) { // Hours
                    durationMs += parseInt(match[1]) * 60 * 60 * 1000;
                }
                if (match[2]) { // Minutes
                    durationMs += parseInt(match[2]) * 60 * 1000;
                }
            }
            
            // If regex failed but we have a simple hour format (e.g., "~14h")
            if (durationMs === 0) {
                const simpleHourMatch = durationString.match(/(\d+)\s*h/i);
                if (simpleHourMatch && simpleHourMatch[1]) {
                    durationMs += parseInt(simpleHourMatch[1]) * 60 * 60 * 1000;
                }
            }

            if (durationMs > 0) {
                return new Date(startTime.getTime() + durationMs);
            }
            return startTime;
        }

        // Robustly calculates city stays based on event types, locations, and datetimes, independent of event titles.
        function calculateCityStaysRobust(itinerary) {
            const segments = {};
            let currentBaseCity = null;
            let segmentStart = null;

            // Mappings for visualization consistency (handling different spellings/languages in data vs display)
            // and grouping specific locations into broader hubs.
            const visualizationBaseNames = {
                "Kioto": "Kyoto",
                "Busán": "Busan",
                "Seoul": "Seúl",
                "Taipei": "Taipéi",
                // Handle specific areas that should be grouped into a major hub
                "Susono": "Hakone",
                "Narita": "Tokio",
                // Ensure standard names are also mapped to themselves
                "Tokio": "Tokio",
                "Osaka": "Osaka",
                "Hakone": "Hakone",
                "Seúl": "Seúl",
                "Taipéi": "Taipéi",
                "Busan": "Busan",
                "Kyoto": "Kyoto",
            };

            // Helper to get the standardized visualization name for a base city
            const getVisualizationName = (city) => {
                return visualizationBaseNames[city] || city;
            };

            // Helper to finalize the current segment
            const finalizeSegment = (endTime, transportType) => {
                if (currentBaseCity && segmentStart) {
                    const baseName = getVisualizationName(currentBaseCity);
                    let segmentName = baseName;

                    // DYNAMIC DAY TRIP DETECTION
                    // Check if specific day trip locations were visited during this segment
                    if (baseName === "Kyoto") {
                        const visitedNara = itinerary.some(e => e.location === "Nara" && e.datetime >= segmentStart && e.datetime < endTime);
                        if (visitedNara) {
                            segmentName = "Kyoto (+ Nara)";
                        }
                    }
                    if (baseName === "Busan") {
                         const visitedGyeongju = itinerary.some(e => e.location === "Gyeongju" && e.datetime >= segmentStart && e.datetime < endTime);
                        if (visitedGyeongju) {
                            segmentName = "Busan (+ Gyeongju)";
                        }
                    }

                    // Handle multiple visits (e.g., Tokio Inicio/Fin)
                    let uniqueName = segmentName;

                    if (baseName === "Tokio") {
                        // Specific logic for Tokio (Inicio/Fin) visualization requirement
                        if (!segments.hasOwnProperty("Tokio (Inicio)") && !segments.hasOwnProperty("Tokio (Fin)") && !segments.hasOwnProperty("Tokio")) {
                            // If this is the first Tokio segment calculated so far
                            uniqueName = "Tokio (Inicio)";
                        } else {
                            // If (Inicio) or (Tokio) already exists, this must be (Fin) or later
                            uniqueName = "Tokio (Fin)";
                            // Fallback for more than 2 visits
                            let count = 3;
                            while (segments.hasOwnProperty(uniqueName)) {
                                uniqueName = `Tokio (${count++})`;
                            }
                        }
                    } else {
                        // Generic handling for other repeated cities
                        let count = 1;
                        let tempName = segmentName;
                        while (segments.hasOwnProperty(tempName)) {
                            count++;
                            tempName = `${segmentName} (${count})`;
                        }
                        uniqueName = tempName;
                    }
                    

                    segments[uniqueName] = {
                        start: segmentStart,
                        end: endTime,
                        transport: transportType,
                        baseCity: currentBaseCity, 
                    };
                }
                currentBaseCity = null;
                segmentStart = null;
            };


            // Iterate through the itinerary chronologically
            for (let i = 0; i < itinerary.length; i++) {
                const event = itinerary[i];
                const location = event.location;

                // 1. Start of the trip detection
                if (!currentBaseCity) {
                    // The trip starts upon arrival at the first destination (arrival, lodging, or first activity)
                    const significantStartTypes = ['flight_arrival', 'lodging', 'sleep', 'activity', 'business', 'day_trip'];
                    if (significantStartTypes.includes(event.type) && location && location.toLowerCase() !== 'en vuelo') {
                        currentBaseCity = location;
                        segmentStart = event.datetime;
                    }
                    continue; // Move to the next event
                }

                // 2. Transitions detection (Transport based)
                // We look for 'flight' (international/long distance) or 'transport' (trains/buses)
                if (event.type === 'flight' || event.type === 'transport') {
                    const arrivalTime = calculateArrivalTime(event.datetime, event.duration);
                    let destinationCity = null;

                    // Look ahead to find the destination city after the transport concludes
                    for (let j = i + 1; j < itinerary.length; j++) {
                        const subsequentEvent = itinerary[j];
                        // Check if the event occurs after arrival (with a small tolerance window for slight misalignments)
                        if (subsequentEvent.datetime >= arrivalTime || (Math.abs(subsequentEvent.datetime - arrivalTime) < (2*60*60*1000))) { // 2h tolerance
                            const nextLocation = subsequentEvent.location;
                            // Ensure the next location is valid and not transient
                            if (nextLocation && nextLocation.toLowerCase() !== 'en vuelo') {
                                destinationCity = nextLocation;
                                break;
                            }
                        }
                    }

                    // Normalize current and destination cities for comparison
                    const normalizedCurrent = getVisualizationName(currentBaseCity);
                    const normalizedDestination = destinationCity ? getVisualizationName(destinationCity) : null;

                    if (normalizedDestination && normalizedDestination !== normalizedCurrent) {
                        // We found a transition to a new base region.

                        const transportIcon = event.type === 'flight' ? 'flight_takeoff' : 'train';
                        finalizeSegment(event.datetime, transportIcon); // End previous segment at departure time

                        currentBaseCity = destinationCity; // Use the actual location name from the data
                        segmentStart = arrivalTime; // Start new segment at arrival time
                        continue;
                    }
                }

                // 3. Transitions detection (Lodging based - fallback)
                // This handles cases where transport might not be explicitly logged (e.g. short distance moves).
                if (event.type === 'lodging' || event.type === 'sleep') {
                    const normalizedCurrent = getVisualizationName(currentBaseCity);
                    const normalizedLocation = location ? getVisualizationName(location) : null;

                    if (normalizedLocation && normalizedLocation !== normalizedCurrent) {
                        // If we sleep somewhere new, that's the new base city.
                        // Use 'commute' icon for unspecified transport
                        finalizeSegment(event.datetime, 'commute'); 
                        currentBaseCity = location;
                        segmentStart = event.datetime;
                        continue;
                    }
                }

                 // 4. End of the trip detection
                 if (i === itinerary.length - 1) {
                    if (currentBaseCity) {
                        // The last segment ends at the time of the last event (usually the final flight departure)
                        let finalTransportIcon = 'flight_takeoff'; // Default assumption for end of trip
                        if (event.type === 'transport') {
                            finalTransportIcon = 'train';
                        }
                        
                        finalizeSegment(event.datetime, finalTransportIcon);
                    }
                }
            }
            
            // Cleanup for single Tokio visit: If only "Tokio (Inicio)" exists, rename it to "Tokio".
            if (segments.hasOwnProperty("Tokio (Inicio)") && !segments.hasOwnProperty("Tokio (Fin)")) {
                segments["Tokio"] = segments["Tokio (Inicio)"];
                delete segments["Tokio (Inicio)"];
            }

            // Calculate durations based on the determined segments.
            return calculateDurations(segments);
        }


        // Applies the specific rules for counting days and nights (UTC based)
        function calculateDurations(segments) {
            const THRESHOLD_1PM = 13 * 60; // 13:00 in minutes UTC
            const THRESHOLD_6PM = 18 * 60; // 18:00 in minutes UTC
            const MS_IN_A_DAY = 24 * 60 * 60 * 1000;

            const results = {};

            // We must process segments in chronological order for correct timeline visualization
            const orderedSegmentNames = Object.keys(segments).sort((a, b) => segments[a].start - segments[b].start);

            for (const name of orderedSegmentNames) {
                const segment = segments[name];
                let days = 0;

                const start = segment.start;
                const end = segment.end;

                // Calculate time of day in minutes UTC
                const startTimeInMinutes = start.getUTCHours() * 60 + start.getUTCMinutes();
                const endTimeInMinutes = end.getUTCHours() * 60 + end.getUTCMinutes();

                // Calculate Nights based on UTC date difference
                // This correctly handles the rule: "if we land at 1am, that's a night on that city on the day before"
                // by comparing the start and end dates at 00:00 UTC.
                const startDateUTC = new Date(Date.UTC(start.getUTCFullYear(), start.getUTCMonth(), start.getUTCDate()));
                const endDateUTC = new Date(Date.UTC(end.getUTCFullYear(), end.getUTCMonth(), end.getUTCDate()));

                let nights = Math.round((endDateUTC - startDateUTC) / MS_IN_A_DAY);

                // Calculate Days based on the rules provided
                if (nights === 0) {
                    // Day Trip logic (Same UTC day)
                    // Simplified logic for day trips based on rules:
                    if (startTimeInMinutes < THRESHOLD_6PM) { // Rule 3: Must arrive before 6pm to count as a day
                         if (startTimeInMinutes < THRESHOLD_1PM && endTimeInMinutes >= THRESHOLD_1PM) {
                            // Arrived morning, left afternoon = 1 day
                            days = 1;
                         } else {
                             // Arrived afternoon OR left morning = 0.5 day (assuming a meaningful duration)
                             if ((end.getTime() - start.getTime()) >= (3 * 60 * 60 * 1000)) { // Heuristic: Ensure stay is meaningful (e.g., >= 3 hours)
                                days = 0.5;
                             }
                         }
                    }
                } else {
                    // Multi-day stay
                    days = nights - 1; // Full days in between

                    // Arrival day contribution (Rule 1 & 3)
                    if (startTimeInMinutes < THRESHOLD_1PM) {
                        days += 1; // Arrive before 1pm = Full day
                    } else if (startTimeInMinutes < THRESHOLD_6PM) {
                        days += 0.5; // Arrive between 1pm and 6pm = Half day
                    }
                    // (If after 6pm, contribution is 0)

                    // Departure day contribution (Rule 2)
                    if (endTimeInMinutes >= THRESHOLD_1PM) {
                        // If leaving after 1pm, it adds a half day. If the arrival day was already a full day, this results in 1.5 days for 1 night, etc.
                        days += 0.5; 
                    }
                    // (If before 1pm, contribution is 0)
                }


                // Format days (e.g., 2.5 -> "2½")
                const formattedDays = String(days).replace('.5', '½');

                results[name] = {
                    days: formattedDays,
                    nights: String(nights),
                    transportToNext: segment.transport,
                    startTime: segment.start // Store start time for use in updateCityTimeline
                };
            }
            return results;
        }


        // --- UI RENDERING ---

        // Initialization sequence
        function renderUI() {
            // 1. Render static components first
            renderCityTimeline();
            renderItinerary();
            
            // 2. Show content and hide loader
            mainContent.style.display = 'grid';
            if (window.innerWidth < 1024) {
                 mobileNav.style.display = 'block';
            }
            // Only hide if no error message was displayed during initialization
            if (loadingOverlay.innerHTML.includes('Cargando itinerario')) {
                loadingOverlay.classList.add('hidden');
            }

            // 3. Invalidate size so the map knows its dimensions now that it is visible.
            map.invalidateSize();
            
            // 4. Now update the view (which includes map movements/flyTo).
            updateView();
        }


        // --- RENDER FUNCTIONS ---

        function renderItinerary() {
            itineraryList.innerHTML = '';
            // Group items by date
            const groupedByDate = sortedData.reduce((acc, item, index) => {
                // Use timeZone: 'UTC' to ensure the date grouping is based on the UTC date
                const dateKey = item.datetime.toLocaleDateString('es-ES', { weekday: 'long', month: 'long', day: 'numeric', timeZone: 'UTC' });
                if (!acc[dateKey]) { acc[dateKey] = []; }
                acc[dateKey].push({ ...item, originalIndex: index });
                return acc;
            }, {});

            for (const date in groupedByDate) {
                const dayGroup = document.createElement('div');
                const dayHeader = document.createElement('h3');
                // Added sticky header for better navigation within the list
                dayHeader.className = 'text-lg font-bold text-slate-900 mb-4 pt-5 sticky top-0 bg-white py-2 z-10 shadow-sm';
                dayHeader.textContent = date.charAt(0).toUpperCase() + date.slice(1);
                dayGroup.appendChild(dayHeader);

                groupedByDate[date].forEach(item => {
                    // Use timeZone: 'UTC' to ensure the time displayed is UTC
                    const timeString = item.datetime.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', hour12: true, timeZone: 'UTC' });
                    const container = document.createElement('div');
                    container.className = 'timeline-item-container';
                    container.dataset.index = item.originalIndex;
                    
                    // Refined HTML structure for the timeline item content
                    container.innerHTML = `
                        <div class="timeline-line"></div>
                        <div class="timeline-icon">${icons[item.type] || icons.activity}</div>
                        <div class="timeline-content">
                            <p class="text-sm font-semibold text-slate-500">${timeString}</p>
                            <p class="font-semibold text-lg text-slate-800 mt-1">${item.title}</p>
                            <p class="text-sm text-slate-600 flex items-center gap-2 mt-1">
                                <span class="material-symbols-outlined" style="font-size: 16px;">location_on</span>
                                ${item.location}
                            </p>
                            ${item.duration ? `
                                <div class="flex items-center text-sm text-slate-600 mt-1">
                                    <span class="material-symbols-outlined" style="font-size: 16px; margin-right: 8px;">schedule</span>
                                    <span>${item.duration}</span>
                                </div>` : ''}
                        </div>`;
                    
                    container.addEventListener('click', () => { 
                        currentDayIndex = item.originalIndex; 
                        updateView(); 
                        // On mobile, automatically switch to the details tab when an item is clicked
                        if (window.innerWidth < 1024) {
                            switchToMobileTab('details');
                        }
                    });
                    dayGroup.appendChild(container);
                });
                itineraryList.appendChild(dayGroup);
            }
        }
        

        function renderCityTimeline() {
            // The order is determined by the chronological calculation in calculateCityStaysRobust/calculateDurations.
            const cityOrder = Object.keys(cityStays);

            const timelineDiv = document.createElement('div');
            timelineDiv.className = 'city-timeline';
            
            cityOrder.forEach(city => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'city-timeline-item';
                itemDiv.dataset.city = city;
                
                // Get the dynamically calculated stay info
                const stayInfo = cityStays[city];
                
                // HTML for stay info (days/nights)
                let stayHtml = stayInfo ? `
                    <div class="stay-info">
                        <div class="stay-info-item" title="${stayInfo.days} Días">
                            <span class="material-symbols-outlined">wb_sunny</span>
                            <span class="${String(stayInfo.days).includes('½') ? 'half-day' : ''}">${stayInfo.days}</span>
                        </div>
                        <div class="stay-info-item" title="${stayInfo.nights} Noches">
                            <span class="material-symbols-outlined">dark_mode</span>
                            <span>${stayInfo.nights}</span>
                        </div>
                    </div>` : '';
                
                // HTML for transport icon between cities
                let transportHtml = (stayInfo && stayInfo.transportToNext) ? `
                    <div class="transport-icon">
                        <span class="material-symbols-outlined">${stayInfo.transportToNext}</span>
                    </div>` : '';
                
                // The countryFlags[city] inserts the <span> element required by the flag-icon-css library
                // The keys in countryFlags are configured to match the visualization names generated.
                itemDiv.innerHTML = `
                    <div class="city-timeline-node">${countryFlags[city] || ''}</div>
                    <div class="city-timeline-label">${city}</div>
                    ${stayHtml}
                    ${transportHtml}`;
                timelineDiv.appendChild(itemDiv);
            });
            cityTimelineContainer.innerHTML = '';
            if (Object.keys(cityStays).length > 0) {
                cityTimelineContainer.appendChild(timelineDiv);
            }
        }

        // --- UPDATE VIEW LOGIC ---

        function updateView() {
            if (sortedData.length === 0) return;

            const currentItem = sortedData[currentDayIndex];
            
            // 1. Update Itinerary List Active State
            document.querySelectorAll('.timeline-item-container').forEach(el => el.classList.remove('active'));
            const activeEl = document.querySelector(`.timeline-item-container[data-index="${currentDayIndex}"]`);
            if (activeEl) {
                activeEl.classList.add('active');
                // Smooth scroll the active item into view
                activeEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            
            // 2. Clear Map Layers
            poiLayerGroup.clearLayers();
            if (mainMarker) map.removeLayer(mainMarker);

            // 3. Determine Details Content (POI or Event Details)
            const cityEventTypes = ['activity', 'sleep', 'day_trip', 'business', 'lodging'];
            let displayLocation = currentItem.location;
            
            // Map specific sub-locations/day trips to major areas if needed for POI lookup.
            // Keys must match the POI JSON keys (e.g., Kioto, Busán).
            const cityMap = { 
                "Susono": "Hakone", 
                // "Nara": "Nara", // Nara has its own entry in POIs, so we don't remap it unless desired.
                "Gyeongju": "Busán", 
            };
            
            let poiLookupLocation = displayLocation;
            if (cityMap[displayLocation]) { 
                poiLookupLocation = cityMap[displayLocation]; 
            }
            

            if (cityEventTypes.includes(currentItem.type) && pointsOfInterest[poiLookupLocation]) {
                // Show POIs for the city
                detailsTitle.textContent = `Atracciones en ${currentItem.location}`;
                const cityPOIs = pointsOfInterest[poiLookupLocation];
                
                // Group POIs by category
                const groupedPOIs = cityPOIs.reduce((acc, poi) => {
                    if (!acc[poi.category]) acc[poi.category] = [];
                    acc[poi.category].push(poi);
                    return acc;
                }, {});

                let poiHtml = '<div class="space-y-5 mt-2">';
                
                // Add a highlight box if accommodation needs booking
                if (currentItem.details?.Alojamiento === "NEED TO BOOK") {
                    poiHtml += `<div class="p-4 mb-4 text-sm text-red-800 rounded-lg bg-red-50" role="alert">
                                    <span class="font-medium">¡Atención!</span> Necesitas reservar alojamiento para esta noche.
                                </div>`;
                }

                for (const category in groupedPOIs) {
                    // Get the count for the category
                    const count = groupedPOIs[category].length;

                    // Render collapsible category headers
                    poiHtml += `
                        <div class="poi-category">
                            <h4 onclick="this.nextElementSibling.classList.toggle('open')">
                                <span class="icon-left">
                                    <span class="material-symbols-outlined">${poiIcons[category] || 'place'}</span>
                                    ${category}
                                    <span class="poi-count">(${count})</span>
                                </span>
                                <span class="material-symbols-outlined">expand_more</span>
                            </h4>
                            <div class="poi-list">`;
                    
                    groupedPOIs[category].forEach(poi => {
                        // Render POI details
                        poiHtml += `
                            <div class="poi-item">
                                <p class="poi-name">${poi.name}</p>
                                <p class="poi-desc">${poi.description}</p>
                            </div>`;
                        
                        // Add POI markers to the map
                        if (poi.coords) {
                            const iconHtml = `<span class="material-symbols-outlined">${poiIcons[poi.category] || 'place'}</span>`;
                            const divIcon = L.divIcon({ className: 'leaflet-div-icon', html: iconHtml, iconSize: [30, 30], iconAnchor: [15, 15] });
                            L.marker(poi.coords, { icon: divIcon }).addTo(poiLayerGroup).bindPopup(`<b>${poi.name}</b><br>${poi.category}`);
                        }
                    });
                    poiHtml += `</div></div>`;
                }
                 detailsContent.innerHTML = poiHtml + '</div>' || '<p class="text-slate-500 italic mt-4">No hay puntos de interés para esta ciudad.</p>';
            } else {
                // Show specific event details (e.g., Flight Info)
                detailsTitle.textContent = 'Detalles del Evento';
                let detailsHtml = `<div class="mt-4 p-5 bg-slate-50 rounded-lg shadow-sm"><h3 class="text-xl font-bold text-slate-800 mb-4">${currentItem.title}</h3><div class="space-y-3">`;
                if (currentItem.details) {
                    for (const [key, value] of Object.entries(currentItem.details)) {
                        detailsHtml += `<p><strong class="text-slate-600">${key}:</strong> ${value}</p>`;
                    }
                } else {
                     // If no specific details, check if POIs were missing for an activity type
                     if (cityEventTypes.includes(currentItem.type) && !pointsOfInterest[poiLookupLocation]) {
                        detailsHtml += `<p class="text-slate-500 italic">No hay puntos de interés registrados para ${currentItem.location}.</p>`;
                    } else {
                        detailsHtml += `<p class="text-slate-500 italic">No hay detalles adicionales.</p>`;
                    }
                }
                detailsContent.innerHTML = detailsHtml + '</div></div>';
            }

            // 4. Update Map View and Main Marker
            if (currentItem.coords && currentItem.location.toLowerCase() !== "en vuelo") {
                
                // Create a distinct marker for the main event
                const mainIconHtml = `<div style="background-color: var(--primary-color); color: white; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; border: 3px solid white; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">${icons[currentItem.type] || icons.activity}</div>`;
                const mainIcon = L.divIcon({ className: '', html: mainIconHtml, iconSize: [36, 36], iconAnchor: [18, 18] });

                mainMarker = L.marker(currentItem.coords, { icon: mainIcon }).addTo(map).bindPopup(`<b>${currentItem.title}</b><br>${currentItem.location}`).openPopup();
                
                // Use flyTo for smooth map transition
                map.flyTo(currentItem.coords, 13, { animate: true, duration: 1.5 });
               
            }

            // 5. Update City Timeline Active State
            // We now rely on the current time, not just the location name.
            updateCityTimeline();
            
            // 6. Update Navigation Buttons State
            prevBtn.disabled = currentDayIndex === 0;
            nextBtn.disabled = currentDayIndex === sortedData.length - 1;
        }

        // Determines the active city based on the current event's timestamp and the calculated segments.
        function updateCityTimeline() {
            document.querySelectorAll('.city-timeline-item').forEach(el => el.classList.remove('active'));
            
            if (sortedData.length === 0) return;

            const currentTime = sortedData[currentDayIndex].datetime;
            let activeCity = null;

            // Iterate through the calculated city stays (which are chronologically ordered).
            for (const cityName in cityStays) {
                const stay = cityStays[cityName];
                // Check if the current event time is greater than or equal to the segment start time.
                // Since the iteration is chronological, the last segment that satisfies this condition is the active one.
                if (currentTime >= stay.startTime) {
                    activeCity = cityName;
                }
            }
            
            if(activeCity) {
                const activeCityEl = document.querySelector(`.city-timeline-item[data-city="${activeCity}"]`);
                if (activeCityEl) {
                    activeCityEl.classList.add('active');
                    // Ensure the active city is visible in the horizontal scroll
                    activeCityEl.scrollIntoView({ behavior: 'smooth', inline: 'center' });
                }
            }
        }

        // --- Event Handlers ---
        prevBtn.addEventListener('click', () => { if (currentDayIndex > 0) { currentDayIndex--; updateView(); } });
        nextBtn.addEventListener('click', () => { if (currentDayIndex < sortedData.length - 1) { currentDayIndex++; updateView(); } });

        // --- Mobile Navigation Logic ---
        const mobileNavBtns = document.querySelectorAll('.mobile-nav-btn');
        
        // Define references to the containers using the data-mobile-tab attribute
        const itineraryContainer = document.querySelector('[data-mobile-tab="itinerary"]');
        const mapContainer = document.querySelector('[data-mobile-tab="map"]');
        const detailsContainer = document.querySelector('[data-mobile-tab="details"]');

        const mobileContainers = {
            'itinerary': itineraryContainer,
            'map': mapContainer,
            'details': detailsContainer
        };

        function switchToMobileTab(target) {
            // Update button active state
            mobileNavBtns.forEach(b => b.classList.remove('active'));
            const activeBtn = document.querySelector(`.mobile-nav-btn[data-target="${target}"]`);
            if (activeBtn) activeBtn.classList.add('active');

            // Update content area visibility
            for (const key in mobileContainers) {
                if (key === target) {
                    mobileContainers[key].classList.add('active');
                } else {
                    mobileContainers[key].classList.remove('active');
                }
            }

            // Specific action for map tab: invalidate size to ensure it renders correctly when becoming visible
            if (target === 'map') {
                // Use a slight delay to ensure the container is visible before invalidating size
                setTimeout(() => map.invalidateSize(), 10);
            }
        }

        mobileNavBtns.forEach(btn => {
            btn.addEventListener('click', () => switchToMobileTab(btn.dataset.target));
        });


        // --- Start the Application ---
        initializeTripData();

    </script>
</body>
</html>
