<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Itinerario de Viaje a Asia 2025 (UTC)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,1,0" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/7.2.1/css/flag-icons.min.css" integrity="sha512-bZBu2H0+FGFz/stDN/L0k8J0G8qVsAL0ht1qg5kTwtAheiXwiRKyCq1frwfbSFSJN3jooR5kauE0YjtPzhZtJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* --- Global Styles & Theme --- */
        :root {
            --primary-color: #059669; /* Emerald-600 */
            --primary-light: #a7f3d0; /* Emerald-200 */
            --bg-color: #f8fafc; /* Slate-50 */
            --card-bg: #ffffff;
        }

        body { font-family: 'Inter', sans-serif; background-color: var(--bg-color); }
        .leaflet-container { border-radius: 0.75rem; z-index: 1; }

        /* --- Loading State --- */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }
        #loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* --- Scrollbar Styles --- */
        .styled-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
        .styled-scrollbar::-webkit-scrollbar-track { background: #f1f5f9; }
        .styled-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        .styled-scrollbar::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        
        /* Custom scrollbar hide utility for timeline */
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }

        /* --- Itinerary Timeline Styles --- */
        .timeline-item-container { position: relative; padding-left: 60px; padding-bottom: 35px; cursor: pointer; transition: opacity 0.3s; }
        .timeline-item-container:hover { opacity: 0.85; }
        .timeline-item-container:last-child { padding-bottom: 10px; }
        .timeline-line { position: absolute; left: 25px; top: 15px; width: 2px; height: 100%; background-color: #e2e8f0; }
        .timeline-item-container:last-child .timeline-line {
            display: none; /* Hide the line after the last item */
        }

        .timeline-icon {
            position: absolute;
            left: 0;
            top: 10px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: #e2e8f0; /* Softer default color */
            border: 3px solid var(--card-bg); /* Match card background to create space */
            display: flex;
            align-items: center;
            justify-content: center;
            color: #64748b;
            transition: background-color 0.3s, border-color 0.3s, box-shadow 0.3s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            z-index: 5;
        }
        .timeline-item-container.active .timeline-icon {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-light);
            box-shadow: 0 4px 10px rgba(5, 150, 105, 0.3);
        }
        .material-symbols-outlined { font-size: 24px; }

        /* --- City Overview Timeline Styles --- */
        .city-timeline { position: relative; display: flex; justify-content: space-between; padding: 2rem 0; margin: 0 1rem; }
        .city-timeline::before { content: ''; position: absolute; top: 20px; left: 0; right: 0; height: 4px; background-color: #e2e8f0; z-index: 5; }
        .city-timeline-item { display: flex; flex-direction: column; align-items: center; position: relative; flex-grow: 1; z-index: 10; min-width: 110px; /* Ensure enough space on mobile scroll */ }
        .city-timeline-node { width: 44px; height: 44px; background-color: #fff; border-radius: 50%; border: 3px solid #cbd5e1; transition: border-color 0.3s ease, box-shadow 0.3s ease; flex-shrink: 0; overflow: hidden; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);}
        
        /* Styling for the Flag Icons - Adjusted for better aspect ratio display */
        .city-timeline-node .fi {
            font-size: 32px; /* Adjusted size */
            line-height: 1em;
            /* Removed explicit width/height to allow natural aspect ratio inside the circle */
        }
        /* Specific fix for rectangular flags like Taiwan's to fill the circle */
        .city-timeline-node .fi-tw {
            transform: scale(1.4);
        }

        .city-timeline-item.active .city-timeline-node {
            border-color: var(--primary-color);
            box-shadow: 0 4px 10px rgba(5, 150, 105, 0.3);
        }
        .city-timeline-label { margin-top: 0.75rem; font-size: 0.875rem; font-weight: 600; color: #475569; transition: color 0.3s ease; text-align: center; }
        .city-timeline-item.active .city-timeline-label { color: var(--primary-color); font-weight: 700; }
        .stay-info { display: flex; gap: 0.75rem; margin-top: 0.25rem; color: #64748b; }
        .stay-info-item { display: flex; align-items: center; font-size: 0.8rem; }
        .stay-info-item span:first-child { margin-right: 4px; }
        .stay-info-item .material-symbols-outlined { font-size: 16px; }
        .half-day { margin-right: 0.25rem; }
        .transport-icon { position: absolute; top: -8px; left: 100%; transform: translateX(-50%); background-color: #fff; border-radius: 50%; z-index: 15; color: #64748b; border: 1px solid #e2e8f0; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); display: flex; align-items: center; justify-content: center; width: 32px; height: 32px; }
        .transport-icon .material-symbols-outlined { font-size: 18px; }
        .city-timeline-item:last-child .transport-icon { display: none; }
        
        /* --- POI Styles (Accordion) --- */
        .poi-category h4 { font-weight: 600; color: #334155; background-color: #f1f5f9; padding: 0.75rem 1rem; border-radius: 0.5rem; margin-bottom: 0.5rem; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s; }
        .poi-category h4:hover { background-color: #e2e8f0; }
        .poi-category h4 .icon-left { display: flex; align-items: center; }
        .poi-category h4 .material-symbols-outlined { font-size: 20px; margin-right: 8px; }
        .poi-count { font-size: 0.8rem; color: #94a3b8; margin-left: 8px; font-weight: 500; }
        /* Smooth accordion transition */
        .poi-list { max-height: 0; overflow: hidden; transition: max-height 0.5s cubic-bezier(0, 1, 0, 1); padding: 0 0.5rem; }
        .poi-list.open { max-height: 1500px; transition: max-height 0.5s ease-in-out; padding: 0.5rem; }
        .poi-item { margin-bottom: 1rem; padding-left: 1.5rem; border-left: 3px solid #e2e8f0; }
        .poi-name { font-weight: 500; }
        .poi-desc { font-size: 0.875rem; color: #64748b; }
        
        /* --- Map Marker Styles --- */
        .leaflet-div-icon { background: #fff; border: 2px solid #64748b; border-radius: 50%; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); }
        .leaflet-div-icon .material-symbols-outlined { font-size: 18px; color: #64748b; }

        /* --- City Timeline Mobile Scroll --- */
        #city-timeline-container {
            position: relative;
        }
        .scroll-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 20;
            transition: opacity 0.2s;
        }
        .scroll-arrow:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        .scroll-arrow.left { left: -10px; }
        .scroll-arrow.right { right: -10px; }

        /* --- City Timeline Responsive Behavior --- */
        @media (min-width: 1024px) {
            .city-timeline {
                flex-wrap: wrap;
                justify-content: center;
            }
            .scroll-arrow {
                display: none;
            }
        }

        /* --- Modal Accordion --- */
        .poi-category-details .poi-list-modal {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-in-out;
        }
        .poi-category-details[open] .poi-list-modal {
            max-height: 1000px; /* Arbitrary large value */
        }

        /* --- Atracciones Button --- */
        #poi-modal-btn {
            background-color: #60A5FA; /* A nice pastel blue - Tailwind's blue-400 */
            color: white;
        }
        #poi-modal-btn:hover {
            background-color: #3B82F6; /* Darker blue for hover - Tailwind's blue-500 */
        }
    </style>
</head>
<body class="text-slate-800 antialiased">

    <div id="loading-overlay">
        <div class="text-center">
            <svg class="animate-spin h-10 w-10 text-emerald-600 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="mt-4 text-slate-600">Cargando itinerario...</p>
        </div>
    </div>

    <div class="container mx-auto p-4 md:p-6 lg:p-8 pb-24 lg:pb-8 max-w-7xl">
        <header class="text-center mb-8">
            <h1 class="text-3xl md:text-5xl font-extrabold text-slate-900 flex items-center justify-center gap-4">
                <span class="material-symbols-outlined text-emerald-600" style="font-size: 40px;">travel_explore</span>
                Itinerario de Viaje a Asia
            </h1>
            <p class="text-lg md:text-xl text-slate-600 mt-3">Septiembre 27 - Octubre 20, 2025 (Horarios en UTC)</p>
        </header>

        <div id="city-timeline-container" class="bg-white p-4 rounded-xl shadow-xl mb-8"></div>

        <main id="main-content" class="grid grid-cols-1 gap-8" style="display: none;">
            
            <!-- Unified Day-by-Day View -->
            <div id="day-view" class="col-span-1 space-y-6">
                <!-- Date Navigator -->
                <div id="date-nav" class="flex items-center justify-between bg-white p-4 rounded-xl shadow-lg">
                    <button id="prev-day" class="p-2 rounded-lg bg-slate-100 hover:bg-slate-200 text-slate-600 transition shadow-sm"><span class="material-symbols-outlined">chevron_left</span></button>
                    <div id="date-display" class="text-center">
                        <h3 class="text-lg font-bold text-slate-900"></h3>
                        <p class="text-sm text-slate-500"></p>
                    </div>
                    <button id="next-day" class="p-2 rounded-lg bg-slate-100 hover:bg-slate-200 text-slate-600 transition shadow-sm"><span class="material-symbols-outlined">chevron_right</span></button>
                </div>

                <!-- Content Grid -->
                <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                    <!-- Itinerary List -->
                    <div id="itinerary-list" class="lg:col-span-1 bg-white p-6 rounded-xl shadow-xl"></div>

                    <!-- Map and Details Column -->
                    <div class="lg:col-span-2 space-y-8">
                        <!-- Atracciones Button -->
                        <div class="flex justify-start">
                            <button id="poi-modal-btn" class="flex items-center gap-2 px-4 py-2 font-semibold rounded-lg shadow-md transition">
                                <span class="material-symbols-outlined">place</span>
                                Atracciones
                            </button>
                        </div>
                         <!-- Map -->
                        <div id="map-container" class="w-full h-96 lg:h-[60vh] bg-white rounded-xl shadow-xl">
                             <div id="map" class="w-full h-full rounded-xl"></div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <!-- Details Modal -->
    <div id="details-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50 p-4">
        <div id="modal-card" class="bg-white rounded-xl shadow-2xl w-full max-w-lg styled-scrollbar transform transition-transform duration-300 ease-out scale-95" style="max-height: 90vh;">
            <div class="flex justify-between items-center border-b p-4">
                <h3 id="modal-title" class="text-xl font-bold text-slate-800"></h3>
                <button id="modal-close-btn" class="p-2 rounded-full text-slate-500 hover:bg-slate-200 hover:text-slate-800 transition">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
            <div id="modal-content" class="p-6 space-y-4" style="max-height: 75vh; overflow-y: auto;">
                <!-- Content will be injected here -->
            </div>
        </div>
    </div>

    <script>
        // --- DATA VARIABLES (To be populated by fetch) ---
        let itineraryData = [];
        let pointsOfInterest = {};
        let sortedData = [];
        let cityStays = {}; // Will be dynamically calculated

        // --- Configuration Constants ---
        const ITINERARY_URL = 'itinerary.json';
        const POI_URL = 'poi.json';

        const poiIcons = {
            'Atracción': 'attractions', 'Templo': 'temple_buddhist', 'Parque': 'park', 'Mirador': 'visibility',
            'Compras': 'shopping_bag', 'Mercado': 'storefront', 'Restaurante': 'restaurant', 'Tienda': 'shopping_cart', 'Tip': 'lightbulb',
        };

        const icons = {
            flight: `<span class="material-symbols-outlined">flight_takeoff</span>`,
            flight_arrival: `<span class="material-symbols-outlined">flight_land</span>`,
            lodging: `<span class="material-symbols-outlined">hotel</span>`,
            sleep: `<span class="material-symbols-outlined">dark_mode</span>`,
            transport: `<span class="material-symbols-outlined">train</span>`,
            activity: `<span class="material-symbols-outlined">local_activity</span>`,
            day_trip: `<span class="material-symbols-outlined">explore</span>`,
            business: `<span class="material-symbols-outlined">work</span>`,
        };
        
        // Flags configuration using flag-icon-css library classes (fi fi-xx)
        const rawCountryFlags = {
            "Tokyo": `<span class="fi fi-jp"></span>`,
            "Hakone": `<span class="fi fi-jp"></span>`,
            "Kyoto": `<span class="fi fi-jp"></span>`,
            "Osaka": `<span class="fi fi-jp"></span>`,
            "Busan": `<span class="fi fi-kr"></span>`,
            "Seoul": `<span class="fi fi-kr"></span>`,
            "Taipei": `<span class="fi fi-tw"></span>`,
        };

        // --- Helper Functions ---
        function normalizeStr(str) {
            if (typeof str !== 'string') return str;
            return str.normalize('NFC').trim();
        }

        function capitalizeFirstLetter(string) {
            return string.charAt(0).toUpperCase() + string.slice(1);
        }

        // Normalize the keys of the flags object for robust matching
        const countryFlags = Object.keys(rawCountryFlags).reduce((acc, key) => {
            acc[normalizeStr(key)] = rawCountryFlags[key];
            return acc;
        }, {});


        // --- Initialization & Setup ---
        const LG_BREAKPOINT = 1024;
        let isMobile = window.innerWidth < LG_BREAKPOINT;
        
        const loadingOverlay = document.getElementById('loading-overlay');
        const mainContent = document.getElementById('main-content');
        const itineraryList = document.getElementById('itinerary-list');
        const mapContainer = document.getElementById('map-container');
        const prevDayBtn = document.getElementById('prev-day');
        const nextDayBtn = document.getElementById('next-day');
        const dateDisplay = document.getElementById('date-display');
        const cityTimelineContainer = document.getElementById('city-timeline-container');
        
        // --- State Variables ---
        let currentDayIndex = 0;
        let cityPageIndex = 0;
        let groupedByDay = [];
        let mainMarker = null;
        let map;
        let poiLayerGroup;

        // --- COORDINATE PARSING & VALIDATION (ROBUST) ---
        // Accepts:
        //  - [lat, lng] (numbers or numeric strings)
        //  - {lat: x, lng: y} or {latitude: x, longitude: y}
        // Returns [latNumber, lngNumber] or null
        function parseCoords(coords) {
            if (!coords) return null;

            // If object with lat/lng keys
            if (typeof coords === 'object' && !Array.isArray(coords)) {
                const lat = coords.lat ?? coords.latitude ?? coords.Lat ?? coords.Latitude;
                const lng = coords.lng ?? coords.longitude ?? coords.Lng ?? coords.Longitude;
                const latN = Number(lat);
                const lngN = Number(lng);
                if (isFinite(latN) && isFinite(lngN) && latN >= -90 && latN <= 90 && lngN >= -180 && lngN <= 180) {
                    return [latN, lngN];
                }
                return null;
            }

            // If array-like [lat, lng] possibly with strings
            if (Array.isArray(coords) && coords.length >= 2) {
                const latN = Number(coords[0]);
                const lngN = Number(coords[1]);
                if (isFinite(latN) && isFinite(lngN) && latN >= -90 && latN <= 90 && lngN >= -180 && lngN <= 180) {
                    return [latN, lngN];
                }
            }
            return null;
        }

        // validation helper for lat/lng arrays or objects
        function isValidLatLng(point) {
            if (!point) return false;
            if (Array.isArray(point) && point.length >= 2) {
                const lat = Number(point[0]);
                const lng = Number(point[1]);
                return isFinite(lat) && isFinite(lng) && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
            }
            if (typeof point === 'object') {
                const lat = Number(point.lat ?? point.latitude);
                const lng = Number(point.lng ?? point.longitude);
                return isFinite(lat) && isFinite(lng) && lat >= -90 && lat <= 90 && lng >= -180 && lng <= 180;
            }
            return false;
        }

        // --- DATA FETCHING AND PROCESSING ---
        async function initializeTripData() {
            try {
                initializeMap();
                const [itineraryResponse, poiResponse] = await Promise.all([
                    fetch(ITINERARY_URL),
                    fetch(POI_URL)
                ]);

                if (!itineraryResponse.ok) throw new Error('Failed to load itinerary data');
                if (!poiResponse.ok) throw new Error('Failed to load POI data');

                const itineraryDataRaw = await itineraryResponse.json();
                const poiDataRaw = await poiResponse.json();

                itineraryData = itineraryDataRaw.map(item => ({
                    ...item,
                    datetime: new Date(item.datetime),
                    coords: parseCoords(item.coords),
                    location: normalizeStr(item.location)
                }));

                pointsOfInterest = {};
                for (const city in poiDataRaw) {
                    const normalizedCity = normalizeStr(city);
                    pointsOfInterest[normalizedCity] = poiDataRaw[city].map(poi => ({
                        ...poi,
                        coords: parseCoords(poi.coords)
                    }));
                }

                sortedData = itineraryData.sort((a, b) => a.datetime - b.datetime);

                const byDate = sortedData.reduce((acc, item, index) => {
                    const dateKey = item.datetime.toLocaleDateString('es-ES', { timeZone: 'UTC' });
                    if (!acc[dateKey]) {
                        acc[dateKey] = { date: item.datetime, events: [] };
                    }
                    acc[dateKey].events.push({ ...item, originalIndex: index });
                    return acc;
                }, {});
                groupedByDay = Object.values(byDate);

                cityStays = calculateCityStaysRobust(sortedData);

                if (Object.keys(cityStays).length > 0) {
                    renderUI();
                } else if (sortedData.length > 0) {
                    throw new Error("Itinerary data loaded, but no city stays could be determined.");
                }

            } catch (error) {
                console.error("Error initializing trip data:", error);
                loadingOverlay.innerHTML = `<div class="text-red-500 p-8 bg-white rounded-lg shadow-xl">Error: ${error.message}</div>`;
            }
        }

        // --- DYNAMIC CITY STAY CALCULATION LOGIC (REFACTORED) ---
        function calculateCityStaysRobust(itinerary) {
            const segments = {};
            if (itinerary.length === 0) return {};
            const sleepEvents = itinerary.filter(e => e.type === 'sleep');
            if (sleepEvents.length === 0) return {};

            let currentSegment = { city: null, start: itinerary[0].datetime, end: null, transport: null };
            let lastSleepCity = null;

            itinerary.forEach((event, i) => {
                if (event.type === 'sleep') {
                    if (lastSleepCity === null) { // First sleep of the trip
                        currentSegment.city = event.location;
                        lastSleepCity = event.location;
                        for (let j = i; j >= 0; j--) {
                            const pastEvent = itinerary[j];
                            if (pastEvent.location === currentSegment.city && (pastEvent.type === 'flight_arrival' || pastEvent.type === 'transport' || pastEvent.type === 'activity')) {
                                currentSegment.start = pastEvent.datetime;
                            }
                            if(pastEvent.type === 'flight' && pastEvent.location !== currentSegment.city) break;
                        }
                    } else if (event.location !== lastSleepCity) {
                        let departureEvent = null;
                        for (let j = i; j >= 0; j--) {
                             const prevEvent = itinerary[j];
                             if ((prevEvent.type === 'flight' || prevEvent.type === 'transport') && prevEvent.location !== lastSleepCity) {
                                 departureEvent = prevEvent;
                                 break;
                             }
                        }
                        currentSegment.end = departureEvent ? departureEvent.datetime : event.datetime;
                        currentSegment.transport = departureEvent ? (departureEvent.type === 'flight' ? 'flight_takeoff' : 'train') : 'commute';
                        let segmentName = currentSegment.city;
                        let count = 1;
                        while (segments[segmentName]) {
                            segmentName = `${currentSegment.city} (${count++})`;
                        }

                        segments[segmentName] = { ...currentSegment };
                        currentSegment = { city: event.location, start: departureEvent ? departureEvent.datetime : event.datetime, end: null, transport: null };
                        lastSleepCity = event.location;
                    }
                }
            });

            if (currentSegment.city) {
                currentSegment.end = itinerary[itinerary.length - 1].datetime;
                const lastEvent = itinerary[itinerary.length - 1];
                if (lastEvent.type === 'flight') currentSegment.transport = 'flight_takeoff';
                else if (lastEvent.type === 'transport') currentSegment.transport = 'train';
                let segmentName = currentSegment.city;
                let count = 1;
                while (segments[segmentName]) {
                    segmentName = `${currentSegment.city} (${count++})`;
                }
                segments[segmentName] = { ...currentSegment };
            }

            const orderedSegments = Object.keys(segments).sort((a, b) => segments[a].start - segments[b].start);
            const finalSegments = {};
            const cityVisits = {};
            orderedSegments.forEach(name => {
                const segment = segments[name];
                const baseCity = segment.city;
                cityVisits[baseCity] = (cityVisits[baseCity] || 0) + 1;
            });

            const multiVisitCities = Object.keys(cityVisits).filter(city => cityVisits[city] > 1);
            const cityCounters = {};
            orderedSegments.forEach(name => {
                const segment = segments[name];
                const baseCity = segment.city;
                let newName = baseCity;
                if (multiVisitCities.includes(baseCity)) {
                    cityCounters[baseCity] = (cityCounters[baseCity] || 0) + 1;
                    newName = `${baseCity} (${cityCounters[baseCity]})`;
                }
                finalSegments[newName] = segment;
                finalSegments[newName].flag = countryFlags[baseCity] || '';
            });
            return calculateDurations(finalSegments);
        }

        function calculateDurations(segments) {
            const THRESHOLD_1PM = 13 * 60;
            const THRESHOLD_6PM = 18 * 60;
            const MS_IN_A_DAY = 24 * 60 * 60 * 1000;
            const results = {};
            const orderedSegmentNames = Object.keys(segments).sort((a, b) => segments[a].start - segments[b].start);

            for (const name of orderedSegmentNames) {
                const segment = segments[name];
                let days = 0;
                const start = segment.start;
                const end = segment.end;
                const startTimeInMinutes = start.getUTCHours() * 60 + start.getUTCMinutes();
                const endTimeInMinutes = end.getUTCHours() * 60 + end.getUTCMinutes();
                const startDateUTC = new Date(Date.UTC(start.getUTCFullYear(), start.getUTCMonth(), start.getUTCDate()));
                const endDateUTC = new Date(Date.UTC(end.getUTCFullYear(), end.getUTCMonth(), end.getUTCDate()));
                let nights = Math.round((endDateUTC - startDateUTC) / MS_IN_A_DAY);

                if (nights === 0) {
                    if (startTimeInMinutes < THRESHOLD_6PM) {
                         if (startTimeInMinutes < THRESHOLD_1PM && endTimeInMinutes >= THRESHOLD_1PM) days = 1;
                         else if ((end.getTime() - start.getTime()) >= (3 * 60 * 60 * 1000)) days = 0.5;
                    }
                } else {
                    days = nights - 1;
                    if (startTimeInMinutes < THRESHOLD_1PM) days += 1;
                    else if (startTimeInMinutes < THRESHOLD_6PM) days += 0.5;
                    if (endTimeInMinutes >= THRESHOLD_1PM) days += 0.5;
                }
                results[name] = {
                    days: String(days).replace('.5', '½'),
                    nights: String(nights),
                    transportToNext: segment.transport,
                    startTime: segment.start,
                    flag: segment.flag
                };
            }
            return results;
        }

        // --- MAP INITIALIZATION ---
        function initializeMap() {
            map = L.map('map').setView([35.6895, 139.6917], 5);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
                maxZoom: 19
            }).addTo(map);
            poiLayerGroup = L.layerGroup().addTo(map);
        }

        // --- UI RENDERING ---
        function handleCityClick(clickedCity) {
            const activeCity = getActiveCity(groupedByDay[currentDayIndex].date);

            if (clickedCity === activeCity) {
                return;
            }

            const cityStartTime = cityStays[clickedCity]?.startTime;
            if (!cityStartTime) {
                return;
            }

            const targetDayIndex = groupedByDay.findIndex(day => {
                const dayDate = day.date;
                return dayDate.getUTCFullYear() === cityStartTime.getUTCFullYear() &&
                       dayDate.getUTCMonth() === cityStartTime.getUTCMonth() &&
                       dayDate.getUTCDate() === cityStartTime.getUTCDate();
            });

            if (targetDayIndex !== -1 && targetDayIndex !== currentDayIndex) {
                currentDayIndex = targetDayIndex;
                renderDayView();
            }
        }

        function renderUI() {
            renderCityTimeline();
            mainContent.style.display = 'grid';
            renderDayView();
            loadingOverlay.classList.add('hidden');
        }

        function renderCityTimeline() {
            const allCities = Object.keys(cityStays);
            const windowSize = 3;

            // Ensure cityPageIndex is within valid bounds for the sliding window.
            if (isMobile) {
                if (cityPageIndex > allCities.length - windowSize) {
                    cityPageIndex = allCities.length - windowSize;
                }
                if (cityPageIndex < 0) {
                    cityPageIndex = 0;
                }
            }

            const citiesToShow = isMobile && allCities.length > windowSize
                ? allCities.slice(cityPageIndex, cityPageIndex + windowSize)
                : allCities;

            const timelineDiv = document.createElement('div');
            timelineDiv.className = 'city-timeline';

            citiesToShow.forEach(city => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'city-timeline-item';
                itemDiv.dataset.city = city;
                const stayInfo = cityStays[city];
                let stayHtml = stayInfo ? `<div class="stay-info"><div class="stay-info-item" title="${stayInfo.days} Días"><span class="material-symbols-outlined">wb_sunny</span><span class="${String(stayInfo.days).includes('½') ? 'half-day' : ''}">${stayInfo.days}</span></div><div class="stay-info-item" title="${stayInfo.nights} Noches"><span class="material-symbols-outlined">dark_mode</span><span>${stayInfo.nights}</span></div></div>` : '';
                let transportHtml = (stayInfo && stayInfo.transportToNext) ? `<div class="transport-icon"><span class="material-symbols-outlined">${stayInfo.transportToNext}</span></div>` : '';
                itemDiv.innerHTML = `<div class="city-timeline-node">${stayInfo.flag || ''}</div><div class="city-timeline-label">${city}</div>${stayHtml}${transportHtml}`;
                itemDiv.addEventListener('click', () => handleCityClick(city));
                timelineDiv.appendChild(itemDiv);
            });

            cityTimelineContainer.innerHTML = '';
            cityTimelineContainer.appendChild(timelineDiv);

            if (isMobile && allCities.length > windowSize) {
                const leftArrow = document.createElement('button');
                leftArrow.className = 'scroll-arrow left';
                leftArrow.innerHTML = `<span class="material-symbols-outlined">arrow_back_ios</span>`;
                leftArrow.disabled = cityPageIndex === 0;
                leftArrow.onclick = () => { if (cityPageIndex > 0) { cityPageIndex--; renderCityTimeline(); } };

                const rightArrow = document.createElement('button');
                rightArrow.className = 'scroll-arrow right';
                rightArrow.innerHTML = `<span class="material-symbols-outlined">arrow_forward_ios</span>`;
                rightArrow.disabled = cityPageIndex >= allCities.length - windowSize;
                rightArrow.onclick = () => { if (cityPageIndex < allCities.length - windowSize) { cityPageIndex++; renderCityTimeline(); } };

                cityTimelineContainer.appendChild(leftArrow);
                cityTimelineContainer.appendChild(rightArrow);
            }

            if (groupedByDay.length > 0) {
                const currentEventTime = groupedByDay[currentDayIndex].date;
                updateCityTimelineActiveState(currentEventTime);
            }
        }

        function renderDayView() {
            if (groupedByDay.length === 0) return;

            const currentDayData = groupedByDay[currentDayIndex];
            const allCities = Object.keys(cityStays);
            const windowSize = 3;

            // --- Center Timeline on Active City (Mobile) ---
            if (isMobile && groupedByDay.length > 0) {
                const activeCity = getActiveCity(currentDayData.date);
                if (activeCity) {
                    const activeCityIndex = allCities.indexOf(activeCity);
                    if (activeCityIndex !== -1) {
                        // Try to center the active city (index - 1)
                        let targetIndex = activeCityIndex - 1;

                        // Clamp the index to be within the valid range
                        const maxIndex = allCities.length > windowSize ? allCities.length - windowSize : 0;
                        targetIndex = Math.max(0, Math.min(targetIndex, maxIndex));

                        if (cityPageIndex !== targetIndex) {
                            cityPageIndex = targetIndex;
                            // Re-render timeline to center on the active city
                            renderCityTimeline();
                        }
                    }
                }
            }

            const date = currentDayData.date;
            const dayName = date.toLocaleDateString('es-ES', { weekday: 'long', timeZone: 'UTC' });
            dateDisplay.innerHTML = `
                <h3 class="text-lg font-bold text-slate-900">${capitalizeFirstLetter(dayName)}</h3>
                <p class="text-sm text-slate-500">${date.toLocaleDateString('es-ES', { month: 'long', day: 'numeric', timeZone: 'UTC' })}</p>`;
            prevDayBtn.disabled = currentDayIndex === 0;
            nextDayBtn.disabled = currentDayIndex === groupedByDay.length - 1;

            itineraryList.innerHTML = '';
            currentDayData.events.forEach(item => {
                const timeString = item.datetime.toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit', hour12: true, timeZone: 'UTC' });
                const container = document.createElement('div');
                container.className = 'timeline-item-container group';

                const hasDetails = item.details && Object.keys(item.details).length > 0 && ['flight', 'flight_arrival', 'transport', 'lodging'].includes(item.type);

                const infoIconHtml = hasDetails
                    ? `<span class="material-symbols-outlined text-slate-400 group-hover:text-emerald-600 transition ml-2" style="font-size: 20px;">info</span>`
                    : '';

                container.innerHTML = `
                    <div class="timeline-line"></div>
                    <div class="timeline-icon">${icons[item.type] || icons.activity}</div>
                    <div class="timeline-content">
                        <p class="text-sm font-semibold text-slate-500">${timeString}</p>
                        <div class="flex items-center">
                            <p class="font-semibold text-lg text-slate-800 mt-1">${item.title}</p>
                            ${infoIconHtml}
                        </div>
                        <p class="text-sm text-slate-600 flex items-center gap-2 mt-1"><span class="material-symbols-outlined" style="font-size: 16px;">location_on</span>${item.location}</p>
                        ${item.duration ? `<div class="flex items-center text-sm text-slate-600 mt-1"><span class="material-symbols-outlined" style="font-size: 16px; margin-right: 8px;">schedule</span><span>${item.duration}</span></div>` : ''}
                    </div>`;

                if (hasDetails) {
                    container.addEventListener('click', () => showDetailsModal(item));
                }

                itineraryList.appendChild(container);
            });
            if (currentDayData.events.length === 0) {
                 itineraryList.innerHTML = `<p class="text-slate-500 italic p-4">No hay eventos programados para este día.</p>`;
            }

            updateMap(currentDayData.events);
            // This call is now mainly for highlighting, as centering is handled above
            updateCityTimelineActiveState(currentDayData.date);
        }

        function updateMap(events) {
            if (!map) return;
            poiLayerGroup.clearLayers();
            if (mainMarker) {
                try { map.removeLayer(mainMarker); } catch (e) { /* ignore */ }
                mainMarker = null;
            }

            const allCoords = [];

            events.forEach(item => {
                if (isValidLatLng(item.coords)) {
                    allCoords.push(item.coords);
                    const iconHtml = `<div style="background-color: var(--primary-color); color: white; border-radius: 50%; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center;"><span class="material-symbols-outlined">place</span></div>`;
                    const mainIcon = L.divIcon({ className: '', html: iconHtml, iconSize: [36, 36], iconAnchor: [18, 18] });
                    try {
                        L.marker(item.coords, { icon: mainIcon }).addTo(map).bindPopup(`<b>${item.title}</b><br>${item.location}`);
                    } catch (err) {
                        console.error('Failed to create marker for item with coords', item.coords, err);
                    }
                } else if (item.coords) {
                    console.warn('Skipping invalid itinerary coords for item:', item, 'parsed coords:', item.coords);
                }
            });

            const firstEvent = events[0];
            if (firstEvent) {
                const cityMap = { "Susono": "Hakone", "Narita": "Tokio", "Gyeongju": "Busán" };
                let poiLookupLocation = cityMap[firstEvent.location] || firstEvent.location;
                if (pointsOfInterest[poiLookupLocation]) {
                     pointsOfInterest[poiLookupLocation].forEach(poi => {
                        if (isValidLatLng(poi.coords)) {
                            allCoords.push(poi.coords);
                            const iconHtml = `<span class="material-symbols-outlined">${poiIcons[poi.category] || 'place'}</span>`;
                            const divIcon = L.divIcon({ className: 'leaflet-div-icon', html: iconHtml, iconSize: [30, 30], iconAnchor: [15, 15] });
                            try {
                                let popupContent = `<b>${poi.name}</b><br>${poi.category}`;
                                if (poi.maps_url) {
                                    popupContent += `<br><a href="${poi.maps_url}" target="_blank" rel="noopener noreferrer">Ver en Google Maps</a>`;
                                }
                                L.marker(poi.coords, { icon: divIcon }).addTo(poiLayerGroup).bindPopup(popupContent);
                            } catch (err) {
                                console.error('Failed to create POI marker for', poi, err);
                            }
                        } else if (poi.coords) {
                            console.warn('Skipping invalid POI coords:', poi);
                        }
                    });
                }
            }

            // Filter duplicates and invalid points robustly
            const uniqueCoords = allCoords
                .filter(isValidLatLng)
                .map(pt => [Number(pt[0]), Number(pt[1])])
                .filter((pt, idx, arr) => !arr.slice(0, idx).some(other => other[0] === pt[0] && other[1] === pt[1]));

            if (uniqueCoords.length > 1) { // If more than one point, use bounds
                try {
                    const bounds = L.latLngBounds(uniqueCoords);
                    map.invalidateSize();
                    if (bounds.isValid && bounds.getNorthWest && bounds.getSouthEast) {
                        map.fitBounds(bounds, { padding: [50, 50], maxZoom: 14 });
                    } else {
                        console.warn('Computed bounds are invalid, skipping fitBounds', bounds);
                    }
                } catch (err) {
                    console.error('Error when calling fitBounds with coords:', uniqueCoords, err);
                }
            } else if (uniqueCoords.length === 1) { // If only one point, fly to it
                try {
                    map.invalidateSize();
                    map.setView(uniqueCoords[0], 14);
                } catch (err) {
                    console.error('Error when calling setView with coord:', uniqueCoords[0], err);
                }
            } else {
                // No valid coords to fit map to - optionally center to a fallback
                console.info('No valid coords to fit map, keeping previous view.');
            }
        }

        function getActiveCity(currentTime) {
            let activeCity = null;
            // Find the last city segment whose start time is before or at the current time
            for (const cityName in cityStays) {
                if (currentTime >= cityStays[cityName].startTime) {
                    activeCity = cityName;
                }
            }
            return activeCity;
        }

        function updateCityTimelineActiveState(currentTime) {
            document.querySelectorAll('.city-timeline-item').forEach(el => el.classList.remove('active'));
            const activeCity = getActiveCity(currentTime);

            if (activeCity) {
                const activeCityEl = document.querySelector(`.city-timeline-item[data-city="${activeCity}"]`);
                if (activeCityEl) {
                    activeCityEl.classList.add('active');
                }
            }
        }

        // --- Event Handlers ---
        prevDayBtn.addEventListener('click', () => {
            if (currentDayIndex > 0) {
                currentDayIndex--;
                renderDayView();
            }
        });

        nextDayBtn.addEventListener('click', () => {
            if (currentDayIndex < groupedByDay.length - 1) {
                currentDayIndex++;
                renderDayView();
            }
        });

        window.addEventListener('resize', () => {
            const newIsMobile = window.innerWidth < LG_BREAKPOINT;
            if (newIsMobile !== isMobile) {
                isMobile = newIsMobile;
                // Re-render the city timeline to add/remove arrows and adjust layout
                renderCityTimeline();
            }
        });

        // --- Modal ---
        const detailsModal = document.getElementById('details-modal');
        const modalCard = document.getElementById('modal-card');
        const poiModalBtn = document.getElementById('poi-modal-btn');
        const modalTitle = document.getElementById('modal-title');
        const modalContent = document.getElementById('modal-content');
        const modalCloseBtn = document.getElementById('modal-close-btn');

        function showPoiModal(location) {
            const cityMap = { "Susono": "Hakone", "Narita": "Tokyo", "Gyeongju": "Busan" };
            let poiLookupLocation = cityMap[location] || location;

            modalTitle.textContent = `Puntos de Interés en ${poiLookupLocation}`;

            let contentHtml = '';

            if (pointsOfInterest[poiLookupLocation]) {
                const cityPOIs = pointsOfInterest[poiLookupLocation];
                const groupedPOIs = cityPOIs.reduce((acc, poi) => {
                    if (!acc[poi.category]) acc[poi.category] = [];
                    acc[poi.category].push(poi);
                    return acc;
                }, {});

                contentHtml += `<div class="space-y-4">`;

                for (const category in groupedPOIs) {
                    const count = groupedPOIs[category].length;
                    contentHtml += `
                        <details class="poi-category-details group" open>
                            <summary class="poi-category-summary list-none flex justify-between items-center cursor-pointer p-3 bg-slate-100 rounded-lg hover:bg-slate-200 transition">
                                <div class="flex items-center">
                                    <span class="material-symbols-outlined text-slate-600 mr-3">${poiIcons[category] || 'place'}</span>
                                    <span class="font-semibold text-slate-700">${category}</span>
                                    <span class="text-sm text-slate-500 ml-2">(${count})</span>
                                </div>
                                <span class="material-symbols-outlined transition-transform duration-300 group-open:rotate-180">expand_more</span>
                            </summary>
                            <div class="poi-list-modal p-3 space-y-3">`;
                    groupedPOIs[category].forEach(poi => {
                        let mapsLink = '';
                        if (poi.maps_url) {
                            mapsLink = `<a href="${poi.maps_url}" target="_blank" rel="noopener noreferrer" class="inline-flex items-center gap-1 text-sm text-emerald-600 hover:text-emerald-800 font-semibold mt-1">Ver en Google Maps <span class="material-symbols-outlined" style="font-size: 16px;">open_in_new</span></a>`;
                        }
                        contentHtml += `<div class="poi-item-modal border-l-2 border-slate-200 pl-4 py-2"><p class="font-semibold text-slate-800">${poi.name}</p><p class="text-sm text-slate-600">${poi.description}</p>${mapsLink}</div>`;
                    });
                    contentHtml += `</div></details>`;
                }
                contentHtml += '</div>';
            } else {
                 contentHtml = `<p class="text-slate-500 italic">No hay Puntos de Interés para mostrar en ${poiLookupLocation}.</p>`;
            }

            modalContent.innerHTML = contentHtml;

            detailsModal.classList.remove('hidden');
            detailsModal.classList.add('flex');
            setTimeout(() => { // For transition
                modalCard.classList.remove('scale-95');
                modalCard.classList.add('scale-100');
            }, 10);
        }

        function showDetailsModal(item) {
            modalTitle.textContent = item.title;

            let contentHtml = '';

            // Render item details
            if (item.details && Object.keys(item.details).length > 0) {
                contentHtml += '<div class="space-y-3 p-4 bg-slate-50 rounded-lg shadow-inner">';
                for (const [key, value] of Object.entries(item.details)) {
                    contentHtml += `<p><strong class="text-slate-600 font-semibold">${key}:</strong> <span class="text-slate-800">${value}</span></p>`;
                }
                contentHtml += '</div>';
            }


            if (contentHtml.trim() === '') {
                contentHtml = '<p class="text-slate-500 italic">No hay detalles para mostrar.</p>';
            }

            modalContent.innerHTML = contentHtml;

            detailsModal.classList.remove('hidden');
            detailsModal.classList.add('flex');
            setTimeout(() => { // For transition
                modalCard.classList.remove('scale-95');
                modalCard.classList.add('scale-100');
            }, 10);
        }

        function hideDetailsModal() {
            modalCard.classList.add('scale-95');
            modalCard.classList.remove('scale-100');
            setTimeout(() => {
                detailsModal.classList.add('hidden');
                detailsModal.classList.remove('flex');
            }, 200); // Match transition duration
        }

        modalCloseBtn.addEventListener('click', hideDetailsModal);
        detailsModal.addEventListener('click', (e) => {
            if (e.target === detailsModal) {
                hideDetailsModal();
            }
        });

        poiModalBtn.addEventListener('click', () => {
            const currentDayData = groupedByDay[currentDayIndex];
            if (currentDayData && currentDayData.events.length > 0) {
                const mainLocation = currentDayData.events[0].location;
                showPoiModal(mainLocation);
            } else {
                modalTitle.textContent = 'Atracciones';
                modalContent.innerHTML = '<p class="text-slate-500 italic">No hay una ciudad principal para mostrar Puntos de Interés.</p>';
                detailsModal.classList.remove('hidden');
                detailsModal.classList.add('flex');
                 setTimeout(() => {
                    modalCard.classList.remove('scale-95');
                    modalCard.classList.add('scale-100');
                }, 10);
            }
        });

        // --- Start the Application ---
        initializeTripData();

    </script>
</body>
</html>
